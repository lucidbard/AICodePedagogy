<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digital Archaeology Mystery</title>
  <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt.min.js" onload="console.log('Skulpt loaded')"
    onerror="loadSkulptFallback()"></script>
  <script src="https://unpkg.com/skulpt@0.11.1/dist/skulpt-stdlib.js" onload="console.log('Skulpt stdlib loaded')"
    onerror="console.error('Failed to load Skulpt stdlib')"></script>
  <script>
    // Fallback function to load Skulpt from alternative CDN
    function loadSkulptFallback() {
      console.log('Trying fallback CDN for Skulpt...');
      const script1 = document.createElement('script');
      script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/skulpt/0.11.1/skulpt.min.js';
      script1.onload = () => console.log('Skulpt loaded from fallback');
      script1.onerror = () => console.error('All CDNs failed for Skulpt');
      document.head.appendChild(script1);

      const script2 = document.createElement('script');
      script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/skulpt/0.11.1/skulpt-stdlib.js';
      script2.onload = () => console.log('Skulpt stdlib loaded from fallback');
      document.head.appendChild(script2);
    }
  </script>

  <!-- CodeMirror for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Georgia', serif;
      background: linear-gradient(135deg, #2c1810, #4a3429);
      color: #f4f1e8;
      min-height: 100vh;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      border: 2px solid #8b7355;
    }

    h1 {
      color: #d4af37;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
      color: #c9b037;
      font-style: italic;
      font-size: 1.2em;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: #3a2c1f;
      border-radius: 10px;
      margin: 20px 0;
      border: 1px solid #8b7355;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #d4af37, #ffd700);
      transition: width 0.5s ease;
      width: 0%;
    }

    .game-area {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .story-panel,
    .code-panel {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      padding: 20px;
      border: 1px solid #8b7355;
    }

    /* Multi-cell support */
    .cell-container {
      margin-bottom: 20px;
    }

    .cell-container:last-child {
      margin-bottom: 0;
    }

    .cell-header {
      background: #f7f7f7;
      border-bottom: 1px solid #e1e4e8;
      padding: 8px 15px;
      font-size: 12px;
      color: #586069;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .cell-number {
      font-weight: bold;
      color: #0969da;
    }

    .cell-status {
      margin-left: auto;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: bold;
    }

    .cell-status.pending {
      background: #fff3cd;
      color: #856404;
    }

    .cell-status.completed {
      background: #d1e7dd;
      color: #0f5132;
    }

    .cell-status.current {
      background: #cce7ff;
      color: #0969da;
    }

    /* Stage navigation (dev mode) */
    .dev-nav {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #8b7355;
      z-index: 1000;
      display: none;
    }

    .dev-nav.active {
      display: block;
    }

    .dev-nav button {
      margin: 2px;
      padding: 5px 10px;
      font-size: 12px;
      min-width: 30px;
    }

    .dev-nav button.current-stage {
      background: #d4af37;
      color: #000;
    }

    .dev-nav-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #d4af37;
      border: 1px solid #8b7355;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1001;
      font-size: 12px;
    }

    .story-panel h2,
    .code-panel h2 {
      color: #d4af37;
      margin-bottom: 15px;
      border-bottom: 2px solid #8b7355;
      padding-bottom: 10px;
    }

    /* Story content formatting */
    .story-panel p {
      margin-bottom: 15px;
      line-height: 1.6;
    }

    .story-text {
      line-height: 1.6;
    }

    .story-text p {
      margin-bottom: 15px;
    }

    .story-panel strong,
    .story-text strong {
      color: #d4af37;
      font-weight: bold;
    }

    .story-panel em,
    .story-text em {
      color: #c9b037;
      font-style: italic;
    }

    .story-panel code,
    .story-text code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #60a5fa;
      font-size: 0.9em;
    }

    .story-panel ul,
    .story-text ul {
      margin: 10px 0 15px 20px;
      list-style-type: disc;
    }

    .story-panel li,
    .story-text li {
      margin-bottom: 5px;
      line-height: 1.4;
    }

    .challenge-text {
      background: rgba(139, 115, 85, 0.2);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      border-left: 4px solid #d4af37;
    }

    .code-editor {
      width: 100%;
      height: 200px;
      background: #ffffff;
      color: #000000;
      border: 2px solid #e1e4e8;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 14px;
      resize: vertical;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* CodeMirror specific styles */
    .CodeMirror {
      height: 200px;
      border: 2px solid #e1e4e8;
      border-radius: 8px;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .CodeMirror-focused {
      border-color: #0969da;
      box-shadow: 0 2px 8px rgba(9, 105, 218, 0.3);
    }

    .CodeMirror-scroll {
      max-height: 200px;
    }

    .jupyter-cell {
      background: #ffffff;
      border: 1px solid #cfcfcf;
      border-radius: 8px;
      margin: 20px 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .cell-header {
      background: #f7f7f7;
      border-bottom: 1px solid #e1e4e8;
      padding: 8px 15px;
      font-size: 12px;
      color: #586069;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .cell-number {
      font-weight: bold;
      color: #0969da;
    }

    .button-group {
      margin: 15px 0;
      display: flex;
      gap: 10px;
      justify-content: flex-start;
    }

    button {
      background: linear-gradient(135deg, #8b7355, #a0845c);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    button:hover {
      background: linear-gradient(135deg, #a0845c, #b8956b);
      transform: translateY(-2px);
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .output {
      background: #0f1419;
      border: 1px solid #8b7355;
      border-radius: 5px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      min-height: 100px;
      white-space: pre-wrap;
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .success {
      color: #4ade80;
      background: rgba(74, 222, 128, 0.1);
    }

    .error {
      color: #f87171;
      background: rgba(248, 113, 113, 0.1);
    }

    .hint {
      background: rgba(59, 130, 246, 0.1);
      color: #60a5fa;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      border-left: 4px solid #3b82f6;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .achievement {
      background: linear-gradient(135deg, #d4af37, #ffd700);
      color: #1a1a1a;
      padding: 15px;
      border-radius: 10px;
      margin: 15px 0;
      text-align: center;
      font-weight: bold;
      animation: glow 2s ease-in-out;
    }

    @keyframes glow {

      0%,
      100% {
        box-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
      }

      50% {
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
      }
    }

    .data-sample {
      background: #2a2a2a;
      border: 1px solid #8b7355;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      overflow-x: auto;
    }

    @media (max-width: 768px) {
      .game-area {
        grid-template-columns: 1fr;
      }

      h1 {
        font-size: 2em;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>🏛️ Digital Archaeology Mystery</h1>
      <p class="subtitle">Code Your Way Through Ancient Secrets</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <p>Stage <span id="currentStage">1</span> of <span id="totalStages">9</span></p>
    </div>

    <div class="game-area">
      <div class="story-panel">
        <h2>📜 Investigation Log</h2>
        <div id="storyContent"></div>
        <div class="challenge-text" id="challengeText"></div>
        <div id="dataDisplay"></div>
      </div>
      <div class="code-panel">
        <h2>💻 Digital Analysis Tools</h2>
        <div id="cellContainer">
          <!-- Cells will be dynamically created here -->
        </div>
        <div id="output" class="output"></div>

        <div class="button-group">
          <button onclick="runCode()">▶️ Run</button>
          <button onclick="getHint()">💡 Hint</button>
          <button onclick="resetCode()">🔄 Reset</button>
        </div>

        <div id="hintArea"></div>
      </div>
    </div>
    <div id="achievementArea"></div>
  </div>

  <!-- Developer Navigation -->
  <div class="dev-nav-toggle" onclick="toggleDevNav()">🔧 Dev</div>
  <div class="dev-nav" id="devNav">
    <div style="color: #d4af37; font-weight: bold; margin-bottom: 5px;">Stage Navigation:</div>
    <div id="devNavButtons"></div>
  </div>

  <script>    // Game state
    let currentStage = 1;
    const totalStages = 9;
    let stages = [];
    let shownHints = {}; // Track which hints have been shown for each stage

    // Multi-cell support
    let codeEditors = []; // Array of CodeMirror instances
    let currentCellIndex = 0; // Which cell is currently active
    let cellStates = {}; // Track cell completion status per stage
    let pythonContext = {}; // Shared Python execution context

    // Initialize Skulpt for Python execution
    function outf(text) {
      const output = document.getElementById("output");
      output.textContent += text;
    }

    function builtinRead(x) {
      if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
        throw "File not found: '" + x + "'";
      return Sk.builtinFiles["files"][x];
    }

    // Game stages definition
    function initializeStages() {
      stages = [{
        title: "The Mysterious Manuscript",
        story: `Dr. Elena Rodriguez has discovered fragments of an ancient manuscript in the digital archives of the Alexandria Library. The fragments contain references to a lost civilization, but they're scattered and encoded. 

You've been called in as a digital archaeologist to help piece together this mystery using computational analysis.

<strong>🔍 Python Concepts: Variables and Print Statements</strong>

In Python, we store information in <em>variables</em>. Think of variables as labeled boxes that hold data:
• Text (strings) must be in quotes: <code>name = "Alexandria"</code>
• Numbers don't need quotes: <code>count = 23</code>
• Use <code>print()</code> to display information

Practice using variables and print statements with the manuscript data provided below.`,
        challenge: "Your task: Complete the code to store the fragment count as a variable, then display both pieces of information using print statements.",
        data: `Manuscript ID: "MS-ALEX-2847"
Fragment Count: 23`,
        starterCode: `# Store the manuscript data as variables and display them
# We've started with the catalog number - you complete the fragment count

catalog_number = "MS-ALEX-2847"
# Create a variable called fragment_count and set it to 23

# Print both variables using print statements
print("Manuscript Catalog:" + catalog_number)
# Add your print statement for fragment_count here
`,
        solution: `catalog_number = "MS-ALEX-2847"
fragment_count = 23
print("Manuscript Catalog:", catalog_number)
print("Fragments Found:", fragment_count)`,
        hints: [
          "Variables store data. Use = to assign values to variable names.",
          "String variables need quotes: my_text = \"Hello\"",
          "Number variables don't need quotes: my_number = 42",
          "Use print() to display variable contents."
        ]
      }, {
        title: "Analyzing Fragment Lengths",
        story: `The manuscript fragments vary greatly in length. Some are mere words, others are complete sentences. Understanding the distribution of fragment sizes might reveal patterns about how the original text was structured.

<strong>🔍 Python Concepts: Lists, For Loops, and Conditional Statements</strong>

<em>Lists</em> store multiple values in a single variable:
• Create lists with square brackets: <code>numbers = [1, 2, 3, 4]</code>
• <em>For loops</em> let you process each item: <code>for item in my_list:</code>
• <code>len()</code> returns how many items are in a list

<em>Conditional statements</em> let your program make decisions:
• <code>if</code> checks a condition: <code>if length < 30:</code>
• <code>elif</code> checks additional conditions: <code>elif length <= 60:</code>
• <code>else</code> handles all other cases: <code>else:</code>
• Use comparison operators: <code><</code> (less than), <code><=</code> (less than or equal), <code>></code> (greater than)
• Remember to indent code inside if/elif/else blocks!

<strong>Example:</strong>
<code>
age = 25
if age < 18:
    print("Child")
elif age <= 65:
    print("Adult") 
else:
    print("Senior")
</code>

Practice combining lists, loops, and conditionals to analyze the fragment data below.`, challenge: "Using the provided fragment lengths list, calculate statistics and count fragments by size categories to understand the distribution.",
        data: `Fragment lengths (characters): [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]

Categories for analysis:
• Short fragments:     less than 30 characters
• Medium fragments:    30-60 characters  
• Long fragments:      more than 60 characters`,
        // Multi-cell configuration for progressive learning
        cells: [
          {
            title: "Task 1: Count Total Fragments",
            instruction: "Use the len() function to count how many fragments we have",
            starterCode: `# Task 1: Count the total number of fragments
fragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]

# Use len() to count total fragments
total_fragments = len(fragment_lengths)
print("Total fragments found:", total_fragments)`,
            expectedOutput: ["Total fragments found: 10"],
            hints: [
              "len() returns the number of items in a list",
              "Use len(fragment_lengths) to count the fragments"
            ]
          },
          {
            title: "Task 2: Calculate Total Characters",
            instruction: "Use a for loop to add up all the fragment lengths",
            starterCode: `# Task 2: Calculate total characters using a for loop
# Note: fragment_lengths is already available from Task 1

total_characters = 0
# Write your for loop here to add up all the lengths
for length in fragment_lengths:
    total_characters = total_characters + length

print("Total characters:", total_characters)`,
            expectedOutput: ["Total characters: 468"],
            hints: [
              "Use 'for length in fragment_lengths:' to loop through each length",
              "Add each length to total_characters inside the loop",
              "Use: total_characters = total_characters + length"
            ]
          },
          {
            title: "Task 3: Categorize Fragments",
            instruction: "Count fragments by size category using if/elif/else statements",
            starterCode: `# Task 3: Count fragments by size category
# Note: fragment_lengths is still available from previous tasks

short_count = 0    # less than 30 characters
medium_count = 0   # 30-60 characters  
long_count = 0     # more than 60 characters

# Write your for loop here to categorize and count each fragment
for length in fragment_lengths:
    if length < 30:
        short_count = short_count + 1
    elif length >= 30 and length <= 60:
        medium_count = medium_count + 1
    else:
        long_count = long_count + 1

print("Fragment distribution:")
print("Short fragments (< 30 chars):", short_count)
print("Medium fragments (30-60 chars):", medium_count) 
print("Long fragments (> 60 chars):", long_count)`,
            expectedOutput: [
              "Short fragments (< 30 chars): 3",
              "Medium fragments (30-60 chars): 5",
              "Long fragments (> 60 chars): 2"
            ],
            hints: [
              "Use if/elif/else inside the for loop",
              "if length < 30: for short fragments",
              "elif length >= 30 and length <= 60: for medium fragments",
              "else: for long fragments",
              "Remember to indent code inside if/elif/else blocks"
            ]
          }
        ],
        solution: `fragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]

# Task 1: Use len() to count total fragments
total_fragments = len(fragment_lengths)
print("Total fragments found:", total_fragments)

# Task 2: Calculate total characters using a for loop
total_characters = 0
for length in fragment_lengths:
    total_characters = total_characters + length
print("Total characters:", total_characters)

# Task 3: Count fragments by size category
short_count = 0    # less than 30 characters
medium_count = 0   # 30-60 characters  
long_count = 0     # more than 60 characters

for length in fragment_lengths:
    if length < 30:
        short_count = short_count + 1
    elif length >= 30 and length <= 60:
        medium_count = medium_count + 1
    else:
        long_count = long_count + 1

print("Fragment distribution:")
print("Short fragments (< 30 chars):", short_count)
print("Medium fragments (30-60 chars):", medium_count) 
print("Long fragments (> 60 chars):", long_count)

# Bonus: Calculate average length
average_length = total_characters / total_fragments
print("Average fragment length:", round(average_length, 1), "characters")`, hints: [
          "Use len(fragment_lengths) to count how many items are in the list",
          "For loops iterate through each item: for length in fragment_lengths:",
          "Inside the loop, add each length to your total: total_characters = total_characters + length",
          "Use if/elif/else inside the loop: if length < 30: ... elif length <= 60: ... else:",
          "Remember to indent code inside if/elif/else blocks (4 spaces)",
          "Comparison operators: < (less than), <= (less than or equal), > (greater than)"
        ]
      }, {
        title: "Decoding Fragment Languages",
        story: `Dr. Rodriguez has identified that the fragments contain text in multiple ancient languages. Some fragments are in Latin, others in ancient Greek, and some in an unknown script. We need to categorize them to focus our translation efforts.

<strong>🔍 Python Concepts: Conditional Statements (if/elif)</strong>

<em>Conditional statements</em> let your program make decisions:
• <code>if</code> checks a condition: <code>if age >= 18:</code>
• <code>elif</code> checks additional conditions: <code>elif age >= 13:</code>
• <code>==</code> compares values (different from <code>=</code> which assigns)
• Remember to indent code inside if/elif blocks!

Practice using conditional statements to categorize the language codes below.`,
        challenge: "Analyze the language codes and count how many fragments we have for each language type.",
        data: `Language codes: ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]`,
        starterCode: `# Count language types using conditional statements
# Language codes: ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]
# LAT = Latin, GRK = Greek, UNK = Unknown

# Your code here:
`,
        solution: `languages = ["LAT", "GRK", "UNK", "LAT", "UNK", "LAT", "GRK", "LAT", "UNK", "GRK", "LAT", "UNK"]
latin_count = 0
greek_count = 0
unknown_count = 0
for lang in languages:
    if lang == "LAT":
        latin_count = latin_count + 1
    elif lang == "GRK":
        greek_count = greek_count + 1
    elif lang == "UNK":
        unknown_count = unknown_count + 1
print("Latin fragments:", latin_count)
print("Greek fragments:", greek_count)
print("Unknown fragments:", unknown_count)`,
        hints: [
          "if statements check conditions: if variable == \"value\":",
          "elif handles additional conditions: elif variable == \"other\":",
          "Use == to compare values (not = which assigns)",
          "Remember to indent code inside if/elif blocks"
        ]
      }, {
        title: "Dating Analysis",
        story: `Carbon dating results have arrived! Each fragment has been assigned an estimated date range. By analyzing these dates, we might discover if all fragments belong to the same time period or if they span multiple eras.

<strong>🔍 Python Concepts: Finding Min/Max and Range Checking</strong>

Finding the smallest and largest values in data:
• Access list items by index: <code>my_list[0]</code> gets the first item
• Compare numbers: <code>if date &lt; oldest_date:</code>
• Combine conditions: <code>if date >= 100 and date &lt; 200:</code>
• Update tracking variables inside loops

Practice finding minimum and maximum values in the dating data below.`,
        challenge: "Find the oldest and most recent fragments, and identify how many are from each century.",
        data: `Estimated dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]`,
        starterCode: `# Analyze fragment dates to find oldest, newest, and century distribution
# Dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]

# Your code here:
`,
        solution: `dates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]
oldest_date = dates[0]
newest_date = dates[0]
for date in dates:
    if date < oldest_date:
        oldest_date = date
    if date > newest_date:
        newest_date = date
print("Oldest fragment:", oldest_date, "CE")
print("Newest fragment:", newest_date, "CE")
second_century = 0
third_century = 0
fourth_century = 0
for date in dates:
    if date >= 100 and date < 200:
        second_century = second_century + 1
    elif date >= 200 and date < 300:
        third_century = third_century + 1
    elif date >= 300 and date < 400:
        fourth_century = fourth_century + 1
print("2nd century fragments:", second_century)
print("3rd century fragments:", third_century)
print("4th century fragments:", fourth_century)`,
        hints: [
          "Access list items by index: my_list[0] gets the first item",
          "Use < and > to compare numbers: if number < 100:",
          "Combine conditions with 'and': if x >= 100 and x < 200:",
          "Update variables inside loops to track minimum/maximum values"
        ]
      }, {
        title: "Word Frequency Analysis",
        story: `Dr. Rodriguez has translated several key fragments and noticed repeated words that might be significant. These recurring terms could be names, places, or important concepts that unlock the manuscript's meaning.

<strong>🔍 Python Concepts: String Comparison and Finding Maximum Values</strong>

When analyzing text data, we often need to:
• Compare strings using <code>==</code>: <code>if word == "temple":</code>
• Count occurrences by checking each item in a list
• Find the maximum value by comparing numbers
• Convert numbers to strings for display: <code>str(count)</code>

Practice counting word frequencies and finding the most common word in the translated fragments below.`,
        challenge: "Count the frequency of important words across the translated fragments to identify the most significant terms.",
        data: `Key words found: ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]`,
        starterCode: `# Count word frequencies and find the most common word
# Words: ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]

# Your code here:
`,
        solution: `words = ["temple", "gold", "alexandria", "temple", "scroll", "gold", "temple", "alexandria", "wisdom", "gold", "scroll", "temple"]
temple_count = 0
gold_count = 0
alexandria_count = 0
scroll_count = 0
wisdom_count = 0
for word in words:
    if word == "temple":
        temple_count = temple_count + 1
    elif word == "gold":
        gold_count = gold_count + 1
    elif word == "alexandria":
        alexandria_count = alexandria_count + 1
    elif word == "scroll":
        scroll_count = scroll_count + 1
    elif word == "wisdom":
        wisdom_count = wisdom_count + 1
print("Word frequencies:")
print("temple:", temple_count)
print("gold:", gold_count)
print("alexandria:", alexandria_count)
print("scroll:", scroll_count)
print("wisdom:", wisdom_count)
max_count = 0
most_frequent = ""
if temple_count > max_count:
    max_count = temple_count
    most_frequent = "temple"
if gold_count > max_count:
    max_count = gold_count
    most_frequent = "gold"
if alexandria_count > max_count:
    max_count = alexandria_count
    most_frequent = "alexandria"
print("Most frequent word:", most_frequent, "(" + str(max_count) + " times)")`,
        hints: [
          "String comparison works like numbers: if word == \"temple\":",
          "Track the maximum value by comparing with previous max",
          "str() converts numbers to strings for concatenation",
          "Use separate if statements (not elif) when you want to check all conditions"
        ]
      }, {
        title: "The Final Revelation",
        story: `Your analysis has revealed something extraordinary! The fragments aren't just random texts - they're coordinates, directions, and clues to a hidden chamber beneath the Library of Alexandria. The repeated word "temple" refers to a secret repository of scrolls that survived the library's destruction.

<strong>🔍 Python Concepts: String Methods and List Operations</strong>

Advanced string and list techniques for data processing:
• <code>startswith()</code> checks if a string begins with specific characters: <code>if text.startswith("N"):</code>
• <code>append()</code> adds items to a list: <code>my_list.append(item)</code>
• <code>not in</code> checks if something is NOT in a list: <code>if item not in my_list:</code>
• String concatenation with <code>+</code>: <code>"Hello " + "World"</code>

Practice using string methods to decode the coordinate fragments below.`,
        challenge: "Process the coordinate fragments to reveal the location of the hidden chamber.",
        data: `Coordinate clues: ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]`,
        starterCode: `# Process coordinate clues to find the hidden chamber location
# Coordinates: ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]
# N = North latitude, E = East longitude, depth = meters below surface

# Your code here:
`,
        solution: `coordinates = ["N31", "E29", "N31", "E30", "N31", "E29", "depth-15", "N31", "E30", "depth-15"]
latitude_coords = []
longitude_coords = []
depth_coords = []
for coord in coordinates:
    if coord.startswith("N"):
        latitude_coords.append(coord)
    elif coord.startswith("E"):
        longitude_coords.append(coord)
    elif coord.startswith("depth"):
        depth_coords.append(coord)
print("Latitude references:")
for lat in latitude_coords:
    print(" ", lat)
print("Longitude references:")
for lon in longitude_coords:
    print(" ", lon)
print("Depth references:")
for depth in depth_coords:
    print(" ", depth)
unique_latitudes = []
unique_longitudes = []
for coord in latitude_coords:
    if coord not in unique_latitudes:
        unique_latitudes.append(coord)
for coord in longitude_coords:
    if coord not in unique_longitudes:
        unique_longitudes.append(coord)
print("\\nFinal coordinates:")
print("Latitude:", unique_latitudes[0])
print("Longitude:", unique_longitudes[0] + " to " + unique_longitudes[1])
print("Depth: 15 meters below surface")
print("\\n🏛️ DISCOVERY: Secret chamber located beneath Alexandria!")`,
        hints: [
          "startswith() checks if a string begins with specific characters",
          "append() adds items to a list: my_list.append(item)",
          "'not in' checks if an item is NOT in a list", "Access list items by index: my_list[0], my_list[1], etc."
        ]
      },
      {
        title: "AI Assistant Integration", story: `The archaeological team has gained access to an advanced AI assistant to help analyze the remaining fragments. Dr. Rodriguez wants to understand how to effectively communicate with AI systems to accelerate the research process.

<strong>🤖 AI Concepts: Understanding AI Assistants</strong>

AI assistants like ChatGPT, Claude, or GitHub Copilot can help with:
• Writing code based on descriptions: "Create a function that calculates average"
• Explaining existing code: "What does this loop do?"
• Debugging errors: "Why am I getting this error message?"
• Optimizing solutions: "How can I make this code more efficient?"

AI assistants work best when you provide:
• Clear, specific requests
• Context about what you're trying to achieve
• Examples of input and expected output
• Information about any constraints or requirements

Practice AI-assisted thinking by clearly describing your analysis goals before coding.`,
        challenge: "Use AI-assisted thinking to analyze metadata about the manuscript fragments. Practice describing what you want in clear language before writing code.",
        data: `Fragment metadata: 
Fragment IDs: ["F001", "F002", "F003", "F004", "F005"]
Condition scores (1-10): [8, 3, 9, 6, 7]
Translation difficulty (1-5): [2, 5, 1, 4, 3]`,
        starterCode: `# Practice AI-assisted development:
# Step 1: Describe your goal clearly in comments
# Example: "I want to find which fragment has the best condition and which is easiest to translate"

# Step 2: Think about the data
fragment_ids = ["F001", "F002", "F003", "F004", "F005"]
condition_scores = [8, 3, 9, 6, 7]  # Higher = better condition
difficulty_scores = [2, 5, 1, 4, 3]  # Lower = easier to translate

# Your analysis code here:
`,
        solution: `fragment_ids = ["F001", "F002", "F003", "F004", "F005"]
condition_scores = [8, 3, 9, 6, 7]
difficulty_scores = [2, 5, 1, 4, 3]

# Find fragment with best condition (highest score)
best_condition_index = 0
for i in range(len(condition_scores)):
    if condition_scores[i] > condition_scores[best_condition_index]:
        best_condition_index = i

# Find fragment with easiest translation (lowest difficulty)
easiest_translation_index = 0
for i in range(len(difficulty_scores)):
    if difficulty_scores[i] < difficulty_scores[easiest_translation_index]:
        easiest_translation_index = i

print("Best condition fragment:", fragment_ids[best_condition_index])
print("Condition score:", condition_scores[best_condition_index])
print("Easiest to translate:", fragment_ids[easiest_translation_index])
print("Difficulty score:", difficulty_scores[easiest_translation_index])

# AI tip: Built-in functions can make this simpler!
print("\\nUsing AI-suggested built-ins:")
print("Best condition:", fragment_ids[condition_scores.index(max(condition_scores))])
print("Easiest translation:", fragment_ids[difficulty_scores.index(min(difficulty_scores))])`,
        hints: [
          "When working with AI: Describe your goal before coding",
          "Think about what 'best condition' means (highest number?)",
          "Think about what 'easiest translation' means (lowest difficulty?)",
          "AI assistants can suggest built-in functions like max(), min(), index()"
        ]
      },
      {
        title: "Effective Prompt Engineering", story: `Dr. Rodriguez needs to extract specific information from a large database of ancient texts. She's learning that the way you ask questions to an AI system greatly affects the quality of the response.

<strong>🎯 Prompt Engineering Principles:</strong>

<strong>Be Specific:</strong>
❌ "Help me with data analysis"
✅ "Help me find the most common words in a list of ancient text fragments"

<strong>Provide Context:</strong>
❌ "Fix this code"
✅ "This code should count languages but isn't working. I'm getting a NameError on line 3"

<strong>Give Examples:</strong>
❌ "Format the output nicely"
✅ "Format like this: 'Fragment F001: Condition 8/10, Difficulty 2/5'"

<strong>Specify Constraints:</strong>
❌ "Make it better"
✅ "Optimize for readability, avoid complex functions, explain each step"

Practice writing clear, specific prompts for analyzing the research team data below.`,
        challenge: "Practice prompt engineering by describing exactly what analysis you want to perform on the manuscript data, then implement it.",
        data: `Research teams and their specialties:
Teams: ["Linguistics", "Dating", "Preservation", "Digital"]
Fragment assignments: [3, 2, 1, 4]
Completion rates: [0.8, 1.0, 0.5, 0.9]`,
        starterCode: `# PROMPT ENGINEERING PRACTICE:
# Write a clear, specific prompt describing what you want to analyze:
# 
# Your detailed prompt (write it as a comment):
# 

# Data to work with:
teams = ["Linguistics", "Dating", "Preservation", "Digital"]
assignments = [3, 2, 1, 4]
completion_rates = [0.8, 1.0, 0.5, 0.9]  # 0.0 = 0%, 1.0 = 100%

# Your implementation here:
`,
        solution: `# PROMPT ENGINEERING PRACTICE:
# Good prompt: "Analyze research team performance by finding the team
# with highest completion rate, calculating total fragments processed,
# and displaying a performance report for each team showing name,
# assignments, completion rate, and estimated completed fragments."

teams = ["Linguistics", "Dating", "Preservation", "Digital"]
assignments = [3, 2, 1, 4]
completion_rates = [0.8, 1.0, 0.5, 0.9]

# Find team with highest completion rate
best_team_index = 0
for i in range(len(completion_rates)):
    if completion_rates[i] > completion_rates[best_team_index]:
        best_team_index = i

print("=== TEAM PERFORMANCE REPORT ===")
print()

# Display all team metrics
for i in range(len(teams)):
    completed_fragments = int(assignments[i] * completion_rates[i])
    percentage = completion_rates[i] * 100
    print(f"Team: {teams[i]}")
    print(f"  Assigned: {assignments[i]} fragments")
    print(f"  Completion Rate: {percentage:.0f}%")
    print(f"  Estimated Completed: {completed_fragments} fragments")
    print()

print(f"🏆 Best Performance: {teams[best_team_index]} team")
print(f"   Completion Rate: {completion_rates[best_team_index] * 100:.0f}%")

# Calculate total project progress
total_assigned = sum(assignments)
total_completed = sum(assignments[i] * completion_rates[i] for i in range(len(teams)))
overall_progress = total_completed / total_assigned * 100
print(f"\\n📊 Overall Project Progress: {overall_progress:.1f}%")`,
        hints: [
          "Good prompts include: what data you have, what you want to find, how to display results",
          "Be specific about calculations: 'highest rate', 'total completed', etc.",
          "Think about what would be useful to display: percentages, rankings, summaries",
          "Consider edge cases and formatting in your prompt"
        ]
      },
      {
        title: "AI-Powered Code Review and Optimization",
        story: `The archaeological team has developed several analysis scripts, but they want to improve code quality and efficiency. Dr. Rodriguez is learning how to use AI assistants for code review, optimization, and best practices.

<strong>🔍 AI Code Review Process:</strong>

<strong>1. Code Review Prompts:</strong>
• "Review this code for bugs and improvements"
• "Check this code for best practices and readability"
• "Suggest optimizations for performance"
• "Explain what this code does and identify potential issues"

<strong>2. Optimization Prompts:</strong>
• "Make this code more efficient"
• "Reduce the number of loops in this code"
• "Use Python built-in functions to simplify this"
• "Make this code more readable and maintainable"

<strong>3. Learning Prompts:</strong>
• "Explain why this solution is better than my original"
• "What Python concepts should I learn to improve this code?"
• "Show me three different ways to solve this problem"

<strong>Example review process:</strong>
<div class="data-sample">
# Original code (works but could be better):
manuscripts = ["MS1", "MS2", "MS3", "MS4"]
priorities = [3, 1, 4, 2]
urgent_manuscripts = []
for i in range(len(manuscripts)):
    if priorities[i] >= 3:
        urgent_manuscripts.append(manuscripts[i])

# AI-suggested improvement:
manuscripts = ["MS1", "MS2", "MS3", "MS4"]
priorities = [3, 1, 4, 2]
urgent_manuscripts = [ms for ms, pri in zip(manuscripts, priorities) if pri >= 3]
print("Urgent manuscripts:", urgent_manuscripts)
</div>

Practice reviewing and optimizing code with AI assistance.`,
        challenge: "Review the inefficient code below and use AI thinking to identify improvements. Rewrite it using better practices.",
        data: `Fragment Processing Status:
Fragment IDs: ["F101", "F102", "F103", "F104", "F105", "F106"]
Processing times (hours): [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
Status: ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]`,
        starterCode: `# INEFFICIENT CODE TO REVIEW:
# This code works but has several issues - identify and fix them

fragment_ids = ["F101", "F102", "F103", "F104", "F105", "F106"]
processing_times = [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
status = ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]

# Find completed fragments
completed_fragments = []
completed_times = []
counter = 0
while counter < len(fragment_ids):
    if status[counter] == "complete":
        completed_fragments.append(fragment_ids[counter])
        completed_times.append(processing_times[counter])
    counter = counter + 1

# Calculate average time for completed fragments
total_time = 0
for time in completed_times:
    total_time = total_time + time
average_time = total_time / len(completed_times)

print("Completed fragments:", completed_fragments)
print("Average processing time:", average_time)

# Find fragment with longest processing time
longest_time = 0
longest_fragment = ""
for i in range(len(fragment_ids)):
    if processing_times[i] > longest_time:
        longest_time = processing_times[i]
        longest_fragment = fragment_ids[i]
print("Longest processing time:", longest_fragment, "took", longest_time, "hours")`,
        solution: `# OPTIMIZED CODE WITH AI IMPROVEMENTS:
# Key improvements: list comprehensions, built-in functions, better variable names

fragment_ids = ["F101", "F102", "F103", "F104", "F105", "F106"]
processing_times = [2.5, 1.2, 4.8, 3.1, 0.9, 2.3]
status = ["complete", "in-progress", "complete", "complete", "in-progress", "complete"]

# AI Improvement 1: Use list comprehensions and zip for cleaner filtering
completed_data = [(fid, time) for fid, time, stat in zip(fragment_ids, processing_times, status) if stat == "complete"]
completed_fragments, completed_times = zip(*completed_data) if completed_data else ([], [])

# AI Improvement 2: Use built-in functions for calculations
average_time = sum(completed_times) / len(completed_times) if completed_times else 0

print("=== PROCESSING ANALYSIS ===")
print(f"Completed fragments: {list(completed_fragments)}")
print(f"Average processing time: {average_time:.2f} hours")

# AI Improvement 3: Use max() with key parameter for finding extremes
longest_time_index = processing_times.index(max(processing_times))
longest_fragment = fragment_ids[longest_time_index]
longest_time = processing_times[longest_time_index]

print(f"Longest processing: {longest_fragment} ({longest_time} hours)")

# AI Improvement 4: Additional useful analysis
in_progress = [fid for fid, stat in zip(fragment_ids, status) if stat == "in-progress"]
completion_rate = len(completed_fragments) / len(fragment_ids) * 100

print(f"\\nIn progress: {in_progress}")
print(f"Completion rate: {completion_rate:.1f}%")

# AI Improvement 5: Better data structure (bonus)
print("\\n=== ALTERNATIVE: USING DICTIONARIES ===")
fragments_data = [
    {"id": fid, "time": time, "status": stat}
    for fid, time, stat in zip(fragment_ids, processing_times, status)
]

completed = [f for f in fragments_data if f["status"] == "complete"]
avg_time = sum(f["time"] for f in completed) / len(completed)
print(f"Dictionary approach - Average time: {avg_time:.2f} hours")`,
        hints: [
          "Look for: while loops that could be for loops, manual calculations that could use built-ins",
          "Consider: list comprehensions, zip(), max(), min(), sum() functions",
          "Think about: variable names, code readability, duplicated logic",
          "AI tip: Ask 'How can I make this more Pythonic?' for style improvements"
        ]
      }
      ];
    } function loadStage(stageNum) {
      const stage = stages[stageNum - 1];

      document.getElementById("currentStage").textContent = stageNum;

      // Convert line breaks to proper HTML formatting
      const formattedStory = stage.story
        .replace(/\n\n/g, '</p><p>')  // Double line breaks become paragraph breaks
        .replace(/\n/g, '<br>');      // Single line breaks become <br> tags

      document.getElementById("storyContent").innerHTML = `
                <h3>${stage.title}</h3>
                <div class="story-text"><p>${formattedStory}</p></div>
            `;

      document.getElementById("challengeText").innerHTML = `
                <strong>Your Task:</strong> ${stage.challenge}
            `;

      if (stage.data) {
        document.getElementById("dataDisplay").innerHTML = `
<div class="data-sample">
<strong>Data to Analyze:</strong><br>
${stage.data.replace(/\n/g, '<br>')}
</div>
                `;
      }

      // Create cells (single or multiple based on stage configuration)
      createMultipleCells(stage);

      document.getElementById("output").textContent = "";
      document.getElementById("hintArea").innerHTML = "";

      // Clear hint tracking for new stage
      shownHints[stageNum] = [];

      // Remove next stage button if present
      const existingNextBtn = document.getElementById('nextStageBtn');
      if (existingNextBtn) {
        existingNextBtn.remove();
      }

      // Update progress bar
      const progress = (stageNum / totalStages) * 100;
      document.getElementById("progressFill").style.width = progress + "%";

      // Update dev navigation highlight
      updateDevNavHighlight();
    } function runCode() {
      const stage = stages[currentStage - 1];

      // Check if this is a multi-cell stage
      if (stage.cells && stage.cells.length > 0) {
        // Multi-cell stage: run the current cell
        runCellCode(currentCellIndex);
        return;
      }

      // Single-cell stage: use traditional execution
      const code = codeEditor ? codeEditor.getValue() : document.getElementById("codeEditor").value;
      const output = document.getElementById("output");

      output.textContent = "";
      output.className = "output";

      if (!code.trim()) {
        output.textContent = "💡 Enter some Python code and click Run to execute it.";
        output.className = "output";
        return;
      }

      // Check if Skulpt is loaded
      if (typeof Sk === 'undefined') {
        // Fallback mode - simulate some basic functionality
        output.className = "output error";
        output.textContent = "🔍 Python interpreter loading... If this persists, the game is running in demo mode.\n\nYour code would execute:\n" + code;

        // Still check the solution structure for demo purposes
        setTimeout(() => {
          checkSolution(code);
        }, 1000);
        return;
      }

      Sk.pre = "output";
      Sk.configure({
        output: outf,
        read: builtinRead,
        execLimit: 10000
      });

      try {
        const promise = Sk.misceval.asyncToPromise(function () {
          return Sk.importMainWithBody("<stdin>", false, code, true);
        });

        promise.then(function (mod) {
          output.className = "output success";
          checkSolution(code);
        }, function (err) {
          output.className = "output error";
          output.textContent = generateErrorFeedback(err.toString());
        });
      } catch (err) {
        output.className = "output error";
        output.textContent = generateErrorFeedback(err.toString());
      }
    }

    function formatError(error) {
      return generateErrorFeedback(error);
    }

    function generateErrorFeedback(error) {
      const stage = stages[currentStage - 1];

      // Check for unbalanced parentheses first (most specific)
      if (error.includes("SyntaxError") &&
        (error.includes("unexpected EOF") ||
          error.includes("')'") ||
          error.includes("unmatched") ||
          error.includes("closing parenthesis") ||
          error.includes("opening parenthesis"))) {
        return `🔍 Digital Analysis Error: Unbalanced parentheses detected!\n\nYour code has mismatched parentheses ( ). Check for:\n• Every opening parenthesis ( has a matching closing parenthesis )\n• Parentheses are in the correct order\n• No extra or missing parentheses in function calls like print()\n\nTip: Count your parentheses - they should be balanced!\n\nOriginal error: ${error}`;
      } else if (error.includes("SyntaxError")) {
        return `🔍 Digital Analysis Error: Syntax issue detected!\n\nThe computer doesn't understand part of your code. Check for:\n• Missing quotes around text\n• Incorrect indentation\n• Missing colons after if/for statements\n• Unbalanced parentheses ( )\n\nOriginal error: ${error}`;
      } else if (error.includes("NameError")) {
        return `🔍 Archaeological Note: Variable not found!\n\nYou're trying to use a variable that hasn't been defined yet. Make sure you:\n• Spell variable names correctly\n• Define variables before using them\n\nOriginal error: ${error}`;
      } else if (error.includes("IndentationError")) {
        return `🔍 Manuscript Format Error: Indentation issue!\n\nPython uses indentation (spaces) to group code. Make sure:\n• Code inside if/for statements is indented\n• Use consistent spacing (4 spaces recommended)\n\nOriginal error: ${error}`;
      } else {
        return `🔍 Analysis Error: ${error}\n\nDon't worry! Debugging is part of the archaeological process. Check your code carefully and try again.`;
      }
    } function checkSolution(code) {
      // If code parameter is not provided, get it from the editor
      if (!code) {
        code = codeEditor ? codeEditor.getValue() : document.getElementById("codeEditor").value;
      }

      const stage = stages[currentStage - 1];
      const output = document.getElementById("output");
      const outputText = output.textContent;

      // Check for basic required elements first
      const requiredElements = getRequiredElements(currentStage);
      let passed = true;
      let feedback = [];

      for (let element of requiredElements) {
        if (!code.includes(element)) {
          passed = false;
          feedback.push(`Missing: ${element}`);
        }
      }

      // Stage-specific output validation
      if (passed && currentStage === 2) {
        // Stage 2: Fragment analysis - check for specific correct outputs
        const expectedOutputs = [
          "Total fragments found: 10",
          "Total characters: 468",
          "Short fragments (< 30 chars): 3",
          "Medium fragments (30-60 chars): 5",
          "Long fragments (> 60 chars): 2"
        ];

        let correctOutputs = 0;
        for (let expected of expectedOutputs) {
          if (outputText.includes(expected)) {
            correctOutputs++;
          }
        }

        // Require at least 4 out of 5 correct outputs
        if (correctOutputs < 4) {
          passed = false;
          feedback.push("Output doesn't match expected results. Check your calculations!");
        }
      }

      if (passed) {
        output.className = "output success";
        showAchievement(stage.title);
        showNextStageButton();
      } else if (feedback.length > 0) {
        // Add feedback to output without changing existing content
        const feedbackDiv = document.createElement('div');
        feedbackDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: rgba(255, 165, 0, 0.1); border-left: 4px solid #ffa500; color: #ff8c00;';
        feedbackDiv.textContent = '🔍 Almost there! ' + feedback.join(', ');
        output.appendChild(feedbackDiv);
      }
    }

    function showNextStageButton() {
      const buttonGroup = document.querySelector('.button-group');

      // Remove existing next button if present
      const existingNextBtn = document.getElementById('nextStageBtn');
      if (existingNextBtn) {
        existingNextBtn.remove();
      }

      if (currentStage < totalStages) {
        const nextButton = document.createElement('button');
        nextButton.id = 'nextStageBtn';
        nextButton.textContent = '🏛️ Continue to Next Stage';
        nextButton.style.background = 'linear-gradient(135deg, #d4af37, #ffd700)';
        nextButton.style.color = '#1a1a1a';
        nextButton.style.fontWeight = 'bold';
        nextButton.onclick = () => {
          currentStage++;
          loadStage(currentStage);
          nextButton.remove();
        };
        buttonGroup.appendChild(nextButton);
      } else {
        const completeButton = document.createElement('button');
        completeButton.id = 'nextStageBtn';
        completeButton.textContent = '🏛️ View Final Achievement';
        completeButton.style.background = 'linear-gradient(135deg, #d4af37, #ffd700)';
        completeButton.style.color = '#1a1a1a';
        completeButton.style.fontWeight = 'bold';
        completeButton.onclick = () => {
          showFinalAchievement();
          completeButton.remove();
        };
        buttonGroup.appendChild(completeButton);
      }
    } function getRequiredElements(stageNum) {
      const requirements = {
        1: ["catalog_number", "fragment_count", "print"],
        2: ["fragment_lengths", "for", "total_characters", "len", "short_count", "medium_count", "long_count"],
        3: ["languages", "if", "elif", "latin_count", "greek_count"],
        4: ["dates", "oldest_date", "newest_date", "second_century"],
        5: ["words", "temple_count", "most_frequent"],
        6: ["coordinates", "startswith", "append", "unique_latitudes"],
        7: ["fragment_ids", "condition_scores", "best_condition", "easiest_translation"],
        8: ["teams", "completion_rates", "best_team", "performance"],
        9: ["completed_fragments", "average_time", "longest_fragment", "optimization"]
      };
      return requirements[stageNum] || [];
    } function getHint() {
      const stage = stages[currentStage - 1];
      const hintArea = document.getElementById("hintArea");

      if (stage.hints && stage.hints.length > 0) {
        // Initialize hint tracking for current stage if not exists
        if (!shownHints[currentStage]) {
          shownHints[currentStage] = [];
        }

        // Find the next hint to show (first one not yet shown)
        let nextHintIndex = -1;
        for (let i = 0; i < stage.hints.length; i++) {
          if (!shownHints[currentStage].includes(i)) {
            nextHintIndex = i;
            break;
          }
        }        // If we have a new hint to show
        if (nextHintIndex !== -1) {
          // Mark this hint as shown
          shownHints[currentStage].push(nextHintIndex);

          // Create new hint element
          const hintDiv = document.createElement('div');
          hintDiv.className = 'hint';
          hintDiv.innerHTML = `💡 <strong>Archaeological Insight #${shownHints[currentStage].length}:</strong> ${stage.hints[nextHintIndex]}`;

          // Add to existing hints instead of replacing
          hintArea.appendChild(hintDiv);

          // Scroll to the new hint
          hintDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
          // All hints have been shown - only show this message once
          const existingNote = hintArea.querySelector('.hint-complete-note');
          if (!existingNote) {
            const hintDiv = document.createElement('div');
            hintDiv.className = 'hint hint-complete-note';
            hintDiv.style.background = 'rgba(255, 165, 0, 0.1)';
            hintDiv.style.borderLeftColor = '#ffa500';
            hintDiv.innerHTML = `🔍 <strong>Archaeological Note:</strong> You've reviewed all available insights for this stage. Try applying what you've learned!`;
            hintArea.appendChild(hintDiv);
          }
        }
      }
    } function resetCode() {
      const stage = stages[currentStage - 1];

      // Check if this is a multi-cell stage
      if (stage.cells && stage.cells.length > 0) {
        // Multi-cell stage: reset all cells to their starter code
        stage.cells.forEach((cell, index) => {
          if (codeEditors[index]) {
            codeEditors[index].setValue(cell.starterCode || '');
          }
        });

        // Reset cell states
        cellStates[currentStage] = stage.cells.map(() => 'pending');
        cellStates[currentStage][0] = 'current'; // First cell is current
        currentCellIndex = 0;
        updateCellStates();
      } else {
        // Single-cell stage: reset the main editor
        if (codeEditor) {
          codeEditor.setValue(stage.starterCode || '');
        } else {
          const editorElement = document.getElementById("codeEditor");
          if (editorElement) {
            editorElement.value = stage.starterCode || '';
          }
        }
      }

      // Clear output and hints for both types
      document.getElementById("output").textContent = "";
      document.getElementById("hintArea").innerHTML = "";

      // Reset hint tracking for current stage
      shownHints[currentStage] = [];
    }

    function showAchievement(title) {
      const achievementArea = document.getElementById("achievementArea");
      achievementArea.innerHTML = `
                <div class="achievement">
                    🏆 Achievement Unlocked: ${title} Complete!
                    <br>You've mastered another piece of the digital archaeology puzzle!
                </div>
            `;

      setTimeout(() => {
        achievementArea.innerHTML = "";
      }, 3000);
    } function showFinalAchievement() {
      const achievementArea = document.getElementById("achievementArea");
      achievementArea.innerHTML = `
                <div class="achievement">
                    🏛️ CONGRATULATIONS! 🏛️
                    <br><strong>Master Digital Archaeologist & AI Collaborator</strong>
                    <br>You've successfully decoded the ancient manuscript, discovered the hidden chamber beneath Alexandria, and mastered AI-assisted development!
                    <br><br>You've mastered:
                    <br>• Variables (strings, numbers, lists)
                    <br>• Conditional logic (if/elif statements)
                    <br>• Loops (for statements)
                    <br>• Data analysis techniques
                    <br>• AI assistant collaboration
                    <br>• Effective prompt engineering
                    <br>• Code review and optimization
                    <br><br>Your computational skills and AI collaboration have unlocked both ancient history and modern development practices!
                    <br><br>🤖 Ready to work with AI assistants like ChatGPT, Claude, and GitHub Copilot to accelerate your coding journey!
                </div>
            `;
    }    // Initialize the game
    let codeEditor; // CodeMirror instance (for backward compatibility)

    document.addEventListener('DOMContentLoaded', function () {
      initializeStages();
      loadStage(1);
      initializeDevNav();

      // Initialize CodeMirror for syntax highlighting
      // Note: initializeCodeEditor is now called from loadStage
    });

    // Developer navigation functions
    function toggleDevNav() {
      const devNav = document.getElementById('devNav');
      devNav.classList.toggle('active');
    }

    function initializeDevNav() {
      const devNavButtons = document.getElementById('devNavButtons');
      for (let i = 1; i <= totalStages; i++) {
        const button = document.createElement('button');
        button.textContent = i;
        button.onclick = () => jumpToStage(i);
        button.id = `devStage${i}`;
        devNavButtons.appendChild(button);
      }
    }

    function jumpToStage(stageNum) {
      currentStage = stageNum;
      loadStage(stageNum);
      updateDevNavHighlight();
    }

    function updateDevNavHighlight() {
      // Remove current highlighting
      const allButtons = document.querySelectorAll('#devNavButtons button');
      allButtons.forEach(btn => btn.classList.remove('current-stage'));

      // Add highlighting to current stage
      const currentButton = document.getElementById(`devStage${currentStage}`);
      if (currentButton) {
        currentButton.classList.add('current-stage');
      }
    }

    // Multi-cell support functions
    function createMultipleCells(stage) {
      const cellContainer = document.getElementById('cellContainer');
      cellContainer.innerHTML = '';
      codeEditors = [];

      if (stage.cells && stage.cells.length > 0) {
        // Multi-cell stage
        stage.cells.forEach((cell, index) => {
          createCell(cell, index, stage.cells.length);
        });
        currentCellIndex = 0;

        // Initialize cell states for this stage
        if (!cellStates[currentStage]) {
          cellStates[currentStage] = stage.cells.map(() => 'pending');
          cellStates[currentStage][0] = 'current'; // First cell is current
        }

        updateCellStates();
      } else {
        // Single cell stage (backward compatibility)
        const cell = {
          title: "Python Code Cell",
          starterCode: stage.starterCode || "",
          instruction: ""
        };
        createCell(cell, 0, 1);
        currentCellIndex = 0;

        // Set the backward compatibility reference
        codeEditor = codeEditors[0];
      }
    }

    function createCell(cell, index, totalCells) {
      const cellContainer = document.getElementById('cellContainer');

      const cellDiv = document.createElement('div');
      cellDiv.className = 'cell-container';
      cellDiv.innerHTML = `
        <div class="jupyter-cell">
          <div class="cell-header">
            <span class="cell-number">In [${index + 1}]:</span>
            <span>${cell.title}</span>
            <span class="cell-status" id="cellStatus${index}">Pending</span>
          </div>
          <textarea id="codeEditor${index}" class="code-editor" placeholder="# ${cell.instruction || 'Write your Python code here...'}
# Press Run to execute"></textarea>
        </div>
      `;

      cellContainer.appendChild(cellDiv);

      // Initialize CodeMirror for this cell
      const textArea = document.getElementById(`codeEditor${index}`);
      const editor = CodeMirror.fromTextArea(textArea, {
        mode: 'python',
        theme: 'default',
        lineNumbers: true,
        indentUnit: 4,
        smartIndent: true,
        autoCloseBrackets: true,
        matchBrackets: true,
        lineWrapping: true,
        extraKeys: {
          "Ctrl-Enter": () => runCellCode(index),
          "Tab": function (cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.replaceSelection(Array(cm.getOption("indentUnit") + 1).join(" "));
            }
          }
        }
      });

      editor.setValue(cell.starterCode || '');
      codeEditors[index] = editor;

      // Set the backward compatibility reference to the first editor
      if (index === 0) {
        codeEditor = editor;
      }
    }

    function updateCellStates() {
      const stage = stages[currentStage - 1];
      if (!stage.cells) return;

      stage.cells.forEach((cell, index) => {
        const statusElement = document.getElementById(`cellStatus${index}`);
        const state = cellStates[currentStage][index];

        statusElement.textContent = state.charAt(0).toUpperCase() + state.slice(1);
        statusElement.className = `cell-status ${state}`;
      });
    } function runCellCode(cellIndex = null) {
      if (cellIndex === null) {
        cellIndex = currentCellIndex;
      }

      const code = codeEditors[cellIndex].getValue();
      const output = document.getElementById("output");

      output.textContent = "";
      output.className = "output";

      if (!code.trim()) {
        output.textContent = "💡 Enter some Python code and click Run to execute it.";
        output.className = "output";
        return;
      }

      try {
        Sk.pre = "output";
        Sk.configure({
          output: outf,
          read: builtinRead,
          execLimit: 10000
        });

        // Build accumulated code from all previous cells in this stage for shared context
        const stage = stages[currentStage - 1];
        let accumulatedCode = '';

        // Add code from all completed cells for shared context
        for (let i = 0; i <= cellIndex; i++) {
          const cellCode = codeEditors[i].getValue();
          if (cellCode.trim()) {
            accumulatedCode += cellCode + '\n';
          }
        }

        const promise = Sk.misceval.asyncToPromise(function () {
          return Sk.importMainWithBody("<stdin>", false, accumulatedCode, true);
        });

        promise.then(function (mod) {
          output.className = "output success";

          // Check if this cell's solution is correct
          const stage = stages[currentStage - 1];
          if (stage.cells && stage.cells[cellIndex]) {
            checkCellSolution(cellIndex, code);
          } else {
            // Single cell stage - use original validation
            checkSolution(code);
          }
        }, function (err) {
          output.textContent = formatError(err.toString());
          output.className = "output error";
        });
      } catch (err) {
        output.textContent = formatError(err.toString());
        output.className = "output error";
      }
    }

    function checkCellSolution(cellIndex, code) {
      const stage = stages[currentStage - 1];
      const cell = stage.cells[cellIndex];
      const output = document.getElementById("output");
      const outputText = output.textContent;

      let passed = true;
      let feedback = [];

      // Check expected output
      if (cell.expectedOutput) {
        let correctOutputs = 0;
        for (let expected of cell.expectedOutput) {
          if (outputText.includes(expected)) {
            correctOutputs++;
          }
        }

        if (correctOutputs < cell.expectedOutput.length) {
          passed = false;
          feedback.push(`Expected output not found. Looking for: ${cell.expectedOutput.join(', ')}`);
        }
      }

      if (passed) {
        // Mark cell as completed
        cellStates[currentStage][cellIndex] = 'completed';
        updateCellStates();

        // Check if all cells in stage are completed
        const allCompleted = cellStates[currentStage].every(state => state === 'completed');
        if (allCompleted) {
          showAchievement(stage.title);
          showNextStageButton();
        } else {
          // Move to next cell if available
          const nextCellIndex = cellIndex + 1;
          if (nextCellIndex < stage.cells.length) {
            cellStates[currentStage][nextCellIndex] = 'current';
            currentCellIndex = nextCellIndex;
            updateCellStates();

            // Show cell completion message
            const feedbackDiv = document.createElement('div');
            feedbackDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: rgba(74, 222, 128, 0.1); border-left: 4px solid #4ade80; color: #4ade80;';
            feedbackDiv.textContent = `✅ Cell ${cellIndex + 1} completed! Continue to Cell ${nextCellIndex + 1}.`;
            output.appendChild(feedbackDiv);
          }
        }
      } else {
        // Add feedback to output
        const feedbackDiv = document.createElement('div');
        feedbackDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: rgba(255, 165, 0, 0.1); border-left: 4px solid #ffa500; color: #ff8c00;';
        feedbackDiv.textContent = '🔍 Almost there! ' + feedback.join(', ');
        output.appendChild(feedbackDiv);
      }
    }

    function initializeCodeEditor() {
      const textArea = document.getElementById('codeEditor');

      // Initialize CodeMirror
      codeEditor = CodeMirror.fromTextArea(textArea, {
        mode: 'python',
        theme: 'default', // Using default theme for better contrast
        lineNumbers: true,
        indentUnit: 4,
        smartIndent: true,
        autoCloseBrackets: true,
        matchBrackets: true,
        lineWrapping: true,
        extraKeys: {
          "Ctrl-Enter": runCode,
          "Tab": function (cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.replaceSelection(Array(cm.getOption("indentUnit") + 1).join(" "));
            }
          }
        }
      });

      // Set initial value
      const stage = stages[currentStage - 1];
      if (stage && stage.starterCode) {
        codeEditor.setValue(stage.starterCode);
      }
    }
  </script>
</body>

</html>