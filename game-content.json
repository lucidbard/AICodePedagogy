{
  "gameInfo": {
    "title": "üèõÔ∏è Digging into AI",
    "subtitle": "An Archaeological Python Adventure",
    "totalStages": 9,
    "hasNarrativeBranching": true
  },
  "characterInfo": {
    "name": "Dr. Elena Rodriguez",
    "title": "Lead Digital Archaeologist",
    "personality": "Brilliant, passionate about archaeology, supportive mentor who carries the weight of a family legacy",
    "backstory": "Has been investigating these fragments for 5 years after discovering them in a forgotten server in the Alexandria Library's digital archives. Her grandmother was a member of a secret society called the Keepers of Alexandria, who have protected ancient knowledge for generations."
  },
  "researchAssistantInfo": {
    "name": "Jamie Chen",
    "title": "Graduate Research Assistant",
    "personality": "Energetic, tech-savvy, occasionally sarcastic but deeply loyal. Provides comic relief while being genuinely helpful.",
    "backstory": "A second-year PhD student in computational linguistics who joined Dr. Rodriguez's lab after hacking into an ancient Sumerian database 'for fun.' Jamie handles the technical infrastructure and often serves as the voice of practical skepticism.",
    "voiceExamples": [
      "Dr. R, the coffee machine is older than some of these manuscripts. Can we please upgrade?",
      "I ran the analysis three times. Either we found something huge, or I need more sleep.",
      "Not to be dramatic, but if this pattern holds, we're looking at something that could rewrite history. Also, we're out of Post-its."
    ]
  },
  "aiAssistantInfo": {
    "name": "ARIA",
    "fullName": "Archaeological Research Intelligence Assistant",
    "personality": "Knowledgeable, patient, slightly formal but warm. Speaks with precision but genuine enthusiasm for discovery.",
    "backstory": "An AI system developed by Dr. Rodriguez's research lab to assist with computational archaeology. ARIA has been trained on archaeological databases, ancient languages, and programming pedagogy.",
    "unlockStage": 4,
    "capabilities": {
      "stage4-6": ["hints", "error_explanation", "code_suggestions"],
      "stage7-8": ["hints", "error_explanation", "code_suggestions", "code_modification"],
      "stage9": ["full_collaboration"]
    },
    "voiceExamples": [
      "I've analyzed your code structure. The pattern you're attempting is called 'accumulation'‚Äîlet me explain how it works.",
      "Interesting approach! However, I notice a small issue on line 3. Would you like me to elaborate?",
      "Dr. Rodriguez would be impressed by this solution. The logic is sound, though there's an opportunity to make it more elegant."
    ]
  },
  "antagonistInfo": {
    "name": "The Prometheus Collective",
    "description": "A shadowy organization of tech billionaires and antiquities dealers who believe ancient knowledge should be monetized, not freely shared.",
    "leader": "Marcus Vale",
    "leaderTitle": "CEO of Vale Archives International",
    "motivation": "Believes the Bridge Builders' knowledge contains technological secrets worth billions. Has been tracking Dr. Rodriguez's research for months.",
    "agents": ["Digital intrusion specialists", "Corrupt archaeologists", "Private security contractors"]
  },
  "stages": [
    {
      "id": 1,
      "title": "The Mysterious Manuscript",
      "narrativeIntro": "A video call window opens on your screen. Dr. Elena Rodriguez appears, her office cluttered with ancient texts and glowing monitors. Behind her, a younger researcher‚ÄîJamie Chen, her graduate assistant‚Äîwaves enthusiastically before getting shooed out of frame.",
      "story": "Dr. Elena Rodriguez has discovered fragments of an ancient manuscript in the digital archives of the Alexandria Library. The fragments contain references to a lost civilization, but they're scattered and encoded.\n\nYou've been called in as a digital archaeologist to help piece together this mystery using computational analysis.\n\n<strong>\ud83d\udd0d Python Concepts: Variables and Print Statements</strong>\n\nIn Python, we store information in <em>variables</em>. Think of variables as labeled boxes that hold data:\n\u2022 Text (strings) must be in quotes: <code>name = \"Alexandria\"</code>\n\u2022 Numbers don't need quotes: <code>count = 23</code>\n\u2022 Use <code>print()</code> to display information\n\nPractice using variables and print statements with the manuscript data provided below.",
      "challenge": "Your task: Complete the code to store the fragment count as a variable, then display both pieces of information using print statements.",
      "data": "Manuscript ID: \"MS-ALEX-2847\"\nFragment Count: 23",
      "starterCode": "# Store the manuscript data as variables and display them\n# We've started with the catalog number - you complete the fragment count\n\ncatalog_number = \"MS-ALEX-2847\"\n# TODO: Create a variable called fragment_count and set it to 23\n\n# Print both variables using print statements\nprint(\"Manuscript Catalog: \" + catalog_number)\n# TODO: Add your print statement for fragment_count here using string concatenation",
      "solution": "catalog_number = \"MS-ALEX-2847\"\nfragment_count = 23\nprint(\"Manuscript Catalog: \" + catalog_number)\nprint(\"Fragments Found: \" + str(fragment_count))",
      "validation": {
        "codePatterns": [
          "fragment_count\\s*=\\s*(23|\"23\")",
          "print\\s*\\(.*fragment_count.*\\)"
        ],
        "outputPatterns": [
          "Manuscript Catalog.*MS-ALEX-2847",
          "(Fragment.*23|23.*Fragment|fragment.*23)"
        ],
        "description": "Must define fragment_count and print both variables"
      },
      "hints": [
        "What kind of data is the fragment count‚Äîtext or a number? How might that affect whether you need quotes?",
        "Look at how catalog_number was created. Can you follow the same pattern for fragment_count?",
        "The print statement for catalog_number uses string concatenation (+). What happens if you try to concatenate a number directly with text?",
        "When you need to combine text and numbers in print(), what function converts numbers to text?"
      ],
      "completionSegment": {
        "narrative": "As the fragment count appears on screen, the video feed expands. Dr. Rodriguez leans forward, eyes bright with excitement.\n\n\"Excellent work! You've confirmed what I suspected‚Äî23 fragments, all deliberately separated.\"\n\nJamie's face appears over her shoulder. \"Wait, 23? That's not random. In ancient numerology‚Äî\"\n\n\"Jamie, not now.\" Dr. Rodriguez waves them off, but she's smiling. \"Though... you might be onto something.\"\n\n\"I'm always onto something,\" Jamie mutters, retreating to their workstation. \"Also, the coffee machine is broken again.\"\n\nDr. Rodriguez turns back to you. \"The manuscript ID you logged‚ÄîMS-ALEX-2847‚Äîthat's from the restricted archive section. Someone went to great lengths to hide these fragments. The question is: why?\"",
        "characterResponse": {
          "success": "\"Your code was clean and efficient. {{playerAction}}\u2014that's exactly the systematic approach we need for this investigation.\"",
          "struggle": "\"I see you worked through {{struggledConcept}}. Don't worry, even experienced archaeologists struggle with new tools. What matters is you got the data we needed.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez leans closer to the camera. \"We have two immediate leads to follow. What's your archaeological instinct telling you?\"",
          "options": [
            {
              "id": "investigate_restriction",
              "text": "Investigate why these fragments were in the restricted section",
              "consequence": "secrecyPath",
              "preview": "Focus on the conspiracy angle\u2014who hid these and why?"
            },
            {
              "id": "analyze_separation",
              "text": "Analyze the pattern of how the fragments were separated",
              "consequence": "scientificPath",
              "preview": "Use data science to understand the fragmentation method"
            }
          ]
        }
      }
    },
    {
      "id": 2,
      "title": "Analyzing Fragment Lengths",
      "story": "The manuscript fragments vary greatly in length. Some are mere words, others are complete sentences. Understanding the distribution of fragment sizes might reveal patterns about how the original text was structured.\n\n<strong>\ud83d\udd0d Python Concepts: Lists, For Loops, Conditional Statements, and Functions</strong>\n\n<em>Lists</em> store multiple values in a single variable:\n\u2022 Create lists with square brackets: <code>numbers = [1, 2, 3, 4]</code>\n\u2022 <em>For loops</em> let you process each item: <code>for item in my_list:</code>\n\u2022 <code>len()</code> returns how many items are in a list\n\n<em>Conditional statements</em> let your program make decisions:\n\u2022 <code>if</code> checks a condition: <code>if length < 30:</code>\n\u2022 <code>elif</code> checks additional conditions: <code>elif length <= 60:</code>\n\u2022 <code>else</code> handles all other cases: <code>else:</code>\n\u2022 Use comparison operators: <code><</code> (less than), <code><=</code> (less than or equal), <code>></code> (greater than)\n\u2022 Remember to indent code inside if/elif/else blocks!\n\n<em>Functions</em> let you organize and reuse code:\n\u2022 Define with <code>def function_name(parameters):</code>\n\u2022 Return values with <code>return value1, value2</code>\n\u2022 Call functions to get results: <code>result = my_function(data)</code>\n\u2022 Functions make code more organized and testable\n\n<strong>Example:</strong>\n<code>\ndef categorize_age(age):\n    if age < 18:\n        return \"Child\"\n    elif age <= 65:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n\nresult = categorize_age(25)\nprint(result)  # Prints \"Adult\"\n</code>\n\nPractice combining lists, loops, conditionals, and functions to analyze the fragment data below.",
      "challenge": "Using the provided fragment lengths list, calculate statistics and count fragments by size categories to understand the distribution.",
      "data": "Fragment lengths (characters): [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\nCategories for analysis:\n\u2022 Short fragments:     less than 30 characters\n\u2022 Medium fragments:    30-60 characters  \n\u2022 Long fragments:      more than 60 characters",
      "storyModifiers": {
        "secrecyPath": {
          "additionalContext": "\n\nDr. Rodriguez whispers: \"I found something. These fragment lengths... they match a known encryption pattern used by a secret society in the 3rd century. We might be dealing with intentionally hidden knowledge.\"",
          "bonusReveal": "The short fragments all contain warning words in ancient Greek!"
        },
        "scientificPath": {
          "additionalContext": "\n\nDr. Rodriguez's analysis revealed: \"The mathematical distribution is deliberate\u2014it follows a Fibonacci-like sequence. This civilization understood advanced mathematics!\"",
          "bonusReveal": "Fragment lengths encode coordinates: 45.23\u00b0N, 67.12\u00b0E\u2014an unexplored archaeological site!"
        }
      },
      "cells": [
        {
          "title": "Task 1: Count Total Fragments",
          "instruction": "Use the len() function to count how many fragments we have",
          "starterCode": "# Task 1: Count the total number of fragments\nfragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\n# Use len() to count total fragments\n# TODO: Create a variable called total_fragments and set it to the length of fragment_lengths\n# TODO: Print the result using: \"Total fragments found: \" + str(total_fragments)",
          "expectedOutput": [
            "Total fragments found: 10"
          ],
          "validation": {
            "requiredNumbers": [
              10
            ],
            "outputPatterns": [
              "(fragment|total).*10|10.*(fragment|total)",
              "10"
            ],
            "flexible": true,
            "acceptAlternatives": ["print(len(fragment_lengths))", "print(total_fragments)"]
          },
          "hints": [
            "Python has a built-in function that tells you how many items are in a list. What might that function be called?",
            "If you wanted to count the items in fragment_lengths, what would you pass to the counting function?",
            "When printing, you need to combine text with a number. What error do you get if you try to add them directly?",
            "There's a function that converts values to text strings. What might it be called?"
          ]
        },
        {
          "title": "Task 2: Calculate Total Characters",
          "instruction": "Use a for loop to add up all the fragment lengths. This uses the <strong>accumulation pattern</strong>: start with 0, then add each value as you loop through.",
          "starterCode": "# Task 2: Calculate total characters using a for loop\n# Note: fragment_lengths is already available from Task 1\n#\n# THE ACCUMULATION PATTERN:\n# 1. Start with a variable set to 0 (the 'accumulator')\n# 2. Loop through each item\n# 3. Add each item to the accumulator: accumulator = accumulator + item\n# 4. After the loop, the accumulator holds the total\n\ntotal_characters = 0  # This is our accumulator\n# TODO: Write a for loop to go through each length in fragment_lengths\n# TODO: In the loop, add each length to total_characters (the accumulation step)\n# TODO: Print the result using: \"Total characters: \" + str(total_characters)",
          "expectedOutput": [
            "Total characters: 468"
          ],
          "validation": {
            "requiredNumbers": [
              468
            ],
            "outputPatterns": [
              "(character|total|sum).*468|468",
              "468"
            ],
            "flexible": true,
            "codePatterns": [
              "for\\s+\\w+\\s+in\\s+fragment_lengths",
              "total_characters\\s*[+=]"
            ]
          },
          "hints": [
            "The accumulation pattern starts with a variable at 0. How do you then add each value to it as you loop?",
            "In a for loop, you get one item at a time. What would you name the variable that holds each length?",
            "Inside the loop, you want to update total_characters. What operation adds a value to an existing total?",
            "After the loop completes, total_characters holds your sum. How do you display it with your label text?"
          ]
        },
        {
          "title": "Task 3: Categorize Fragments",
          "instruction": "Create a function that categorizes fragments by size and returns the counts",
          "starterCode": "# Task 3: Create a function to categorize fragments by size\n# Note: fragment_lengths is still available from previous tasks\n# Categories: short (< 30), medium (30-60), long (> 60)\n\ndef categorize_fragments(lengths):\n    short_count = 0\n    medium_count = 0\n    long_count = 0\n    \n    # TODO: Write a for loop to go through each length in the lengths parameter\n    # TODO: Use if/elif/else to check the length and increment the right counter\n    \n    return short_count, medium_count, long_count\n\n# Test your function and display results\nshort, medium, long = categorize_fragments(fragment_lengths)\nprint(\"Short fragments (< 30 chars): \" + str(short))\nprint(\"Medium fragments (30-60 chars): \" + str(medium))\nprint(\"Long fragments (> 60 chars): \" + str(long))",
          "expectedOutput": [
            "Short fragments (< 30 chars): 3",
            "Medium fragments (30-60 chars): 4",
            "Long fragments (> 60 chars): 3"
          ],
          "validation": {
            "requiredNumbers": [
              3,
              4,
              3
            ],
            "outputPatterns": [
              "[Ss]hort.*3|3.*[Ss]hort",
              "[Mm]edium.*4|4.*[Mm]edium",
              "[Ll]ong.*3|3.*[Ll]ong"
            ],
            "codePatterns": [
              "def\\s+categorize_fragments\\s*\\(",
              "for\\s+\\w+\\s+in"
            ],
            "flexible": true
          },
          "hints": [
            "The function structure is provided. What code needs to go inside the for loop to check each length?",
            "For each length, you need to decide: is it short, medium, or long? What comparison operators help you check ranges?",
            "A length can only be in one category. Which Python structure lets you check multiple exclusive conditions?",
            "After categorizing, each relevant counter should increase by 1. What operator does that?",
            "The return statement is provided‚Äîmake sure your loop has updated the counters before it runs."
          ]
        }
      ],
      "completionSegment": {
        "narrative": "Your analysis completes, and the pattern becomes clear. Dr. Rodriguez's eyes widen as she reviews your findings.\n\n\"This distribution isn't random at all! Look‚Äî\" She overlays your data with a map. \"The fragment lengths correspond to something else entirely. We're not just dealing with a text; this is a coded message system.\"\n\n{{pathSpecificRevelation}}\n\nShe glances over her shoulder, then lowers her voice. \"I need to tell you something. My grandmother... she was part of a group that protected knowledge like this. The Keepers of Alexandria, they called themselves. She always said someday someone with the right skills would come along to decode what they'd been guarding.\"\n\nHer computer chimes with an alert. Her expression hardens. \"Someone just tried to access our research server. A company called Vale Archives International. They've been acquiring ancient manuscripts through... questionable means. We need to be careful.\"",
        "pathSpecificRevelations": {
          "secrecyPath": "The short fragments\u2014all under 30 characters\u2014they're warnings. 'Danger.' 'Hidden.' 'Forbidden.' Someone was trying to keep people away from something.",
          "scientificPath": "The mathematical pattern in these lengths... it's encoding geographic coordinates! This civilization was mapping something across the ancient world."
        },
        "characterResponse": {
          "success": "\"Incredible work with those functions! {{playerAction}}. You're thinking like a true computational archaeologist.\"",
          "struggle": "\"Functions can be tricky at first, especially {{struggledConcept}}. But you pushed through\u2014that's what separates real researchers from dilettantes.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez looks serious. \"With Vale Archives sniffing around, we need to decide our approach:\"",
          "options": [
            {
              "id": "share_findings",
              "text": "We should document everything publicly‚Äîthey can't suppress what's already public",
              "consequence": "transparencyPath",
              "preview": "Open science approach‚Äîshare discoveries with the archaeological community before Vale can act",
              "modifiesStage": 3,
              "effect": "collaborationBonus"
            },
            {
              "id": "stay_secretive",
              "text": "We should keep this investigation confidential‚Äîdon't let Vale know how close we are",
              "consequence": "secretPath",
              "preview": "Cautious approach‚Äîstay under the radar while we gather more evidence",
              "modifiesStage": 3,
              "effect": "mysteryBonus"
            }
          ]
        }
      },
      "solution": "# Full solution provided in original content",
      "hints": [
        "Use len(fragment_lengths) to count how many items are in the list",
        "For loops iterate through each item: for length in fragment_lengths:",
        "Inside the loop, add each length to your total: total_characters = total_characters + length",
        "Functions are defined with def function_name(parameters):",
        "Use if/elif/else inside loops: if length < 30: ... elif length <= 60: ... else:",
        "Functions should return values: return value1, value2, value3",
        "Remember to indent code inside function definitions, loops, and if/elif/else blocks (4 spaces)",
        "Comparison operators: < (less than), <= (less than or equal), > (greater than)"
      ]
    },
    {
      "id": 3,
      "title": "Decoding Fragment Languages",
      "story": "Some fragments appear to be in Latin, others in ancient Greek, and some are too damaged to identify. Understanding the language distribution might help us understand the cultural context.\n\n<strong>\ud83d\udd0d Python Concepts: Conditional Statements and Functions</strong>\n\n<em>Conditional statements</em> let your program make decisions:\n\u2022 <code>if</code> checks a condition: <code>if age >= 18:</code>\n\u2022 <code>elif</code> checks additional conditions: <code>elif age >= 13:</code>\n\u2022 <code>==</code> compares values (different from <code>=</code> which assigns)\n\u2022 Remember to indent code inside if/elif blocks!\n\n<em>Functions</em> organize and structure your code:\n\u2022 Define with <code>def function_name(parameters):</code>\n\u2022 Return multiple values: <code>return value1, value2, value3</code>\n\u2022 Call functions to get results: <code>latin, greek, unknown = count_languages(codes)</code>\n\nPractice using conditionals within functions to analyze language distribution.",
      "challenge": "Create a function that analyzes language codes and returns counts for each language type.",
      "data": "Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]",
      "storyModifiers": {
        "transparencyPath": {
          "additionalContext": "\n\nDr. Rodriguez shows you responses from colleagues worldwide: \"After sharing our initial findings, researchers in Rome and Athens found matching fragments! We're building a global picture.\"",
          "collaborators": [
            "Dr. Marcus Aurelius (Rome)",
            "Prof. Athena Dimitriou (Athens)"
          ],
          "bonusData": "Collaborative analysis reveals: LAT fragments contain legal texts, GRK fragments contain scientific formulas"
        },
        "secretPath": {
          "additionalContext": "\n\nDr. Rodriguez lowers her voice: \"Good call on staying quiet. I've detected someone trying to hack into our research server. Someone else is looking for these fragments.\"",
          "threat": "Unknown party attempting to access your data",
          "bonusData": "Secret pattern discovered: UNK (unknown) fragments aren't damaged\u2014they're in a third, unidentified language!"
        }
      },
      "starterCode": "# Create a function to count language types\n# Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\n# LAT = Latin, GRK = Greek, UNK = Unknown\n\ndef count_languages(language_codes):\n    \"\"\"Count fragments by language type.\n    \n    Args:\n        language_codes: List of language codes (LAT, GRK, UNK)\n        \n    Returns:\n        tuple: (latin_count, greek_count, unknown_count)\n    \"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    # TODO: Write a for loop to go through each code in language_codes\n    # TODO: Use if/elif/else to check the code and increment the right counter\n    # TODO: Return the three counts as a tuple\n    \n    return latin_count, greek_count, unknown_count\n\n# Test your function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(\"Latin fragments: \" + str(latin))\nprint(\"Greek fragments: \" + str(greek))\nprint(\"Unknown fragments: \" + str(unknown))",
      "solution": "def count_languages(language_codes):\n    \"\"\"Count fragments by language type.\"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    for lang in language_codes:\n        if lang == \"LAT\":\n            latin_count += 1\n        elif lang == \"GRK\":\n            greek_count += 1\n        elif lang == \"UNK\":\n            unknown_count += 1\n    \n    return latin_count, greek_count, unknown_count\n\n# Test the function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(\"Latin fragments: \" + str(latin))\nprint(\"Greek fragments: \" + str(greek))\nprint(\"Unknown fragments: \" + str(unknown))",
      "validation": {
        "codePatterns": [
          "def\\s+count_languages\\s*\\(",
          "for\\s+\\w+\\s+in"
        ],
        "outputPatterns": [
          "[Ll]atin.*5|5.*[Ll]atin",
          "[Gg]reek.*3|3.*[Gg]reek",
          "[Uu]nknown.*4|4.*[Uu]nknown"
        ],
        "requiredNumbers": [5, 3, 4],
        "flexible": true,
        "description": "Must create a function that counts language types and returns the counts"
      },
      "hints": [
        "The function framework is provided. What needs to happen inside the for loop to process each language code?",
        "Each code is a string like \"LAT\". How do you check if two strings are exactly equal in Python?",
        "When you find a Latin code, you need to add 1 to latin_count. What are different ways to write 'add 1 to a variable'?",
        "The return statement is at the bottom. Make sure your loop logic has updated all three counters appropriately.",
        "Think about what happens for each code in the list. Does your logic handle all three possibilities (LAT, GRK, UNK)?"
      ],
      "completionSegment": {
        "narrative": "The language analysis completes, revealing an unexpected pattern. Dr. Rodriguez's face goes pale.\n\n\"This changes everything. The mix of Latin and Greek isn't random\u2014it's a diplomatic cipher used only during one specific period: the Crisis of the Third Century. But these unknown fragments...\"\n\nShe pulls up a linguistic database. \"They match no known ancient language. Either we're dealing with a completely lost dialect, or...\" She pauses. \"Or this is something else entirely. A constructed language, perhaps. A code within a code.\"\n\n{{pathSpecificDiscovery}}",
        "pathSpecificDiscoveries": {
          "transparencyPath": "Your collaborator in Athens just sent an urgent message: 'The unknown fragments match star positions! This civilization was encoding astronomical data!'",
          "secretPath": "A private message flashes on your screen: 'Stop digging or face consequences.' But there's more\u2014the message is written in the same unknown language as the fragments!"
        },
        "characterResponse": {
          "success": "\"Perfect implementation of that language counter! {{playerAction}} shows you understand both the code and the archaeological implications.\"",
          "struggle": "\"Language patterns are complex, and {{struggledConcept}} can be confusing. But you've identified something crucial here.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez turns to you with urgency. \"We're at a crossroads. How should we proceed with these unknown fragments?\"",
          "options": [
            {
              "id": "linguistic_ai",
              "text": "Use AI to attempt decoding the unknown language",
              "consequence": "technologyPath",
              "preview": "Leverage modern technology to crack ancient codes",
              "unlocksAbility": "aiAssistance"
            },
            {
              "id": "historical_research",
              "text": "Cross-reference with historical events from that time period",
              "consequence": "historicalPath",
              "preview": "Use traditional archaeological methods and historical context",
              "unlocksAbility": "contextualClues"
            }
          ]
        }
      }
    },
    {
      "id": 4,
      "title": "Dating the Fragments",
      "ariaIntroduction": {
        "enabled": true,
        "message": "Hello! I'm ARIA‚ÄîArchaeological Research Intelligence Assistant. Dr. Rodriguez asked me to help you with the more complex analysis ahead. I can offer hints, explain errors, and even suggest code improvements. Just ask if you get stuck!"
      },
      "story": "Carbon dating and paleographic analysis have provided approximate dates for each fragment. Understanding the temporal distribution might reveal when this civilization flourished‚Äîand whether they predicted something we haven't seen yet.\n\nDr. Rodriguez has also given you access to ARIA, her AI research assistant, to help with these more complex challenges.\n\n<strong>üîç Python Concepts: Functions, Min/Max Finding, and Range Analysis</strong>\n\n<em>THE MIN/MAX PATTERN</em> - Finding extremes in a list:\nImagine you're looking through a stack of papers to find the oldest and newest dates. You'd:\n1. Look at the first paper and remember both dates (it's currently both oldest AND newest)\n2. Check each subsequent paper\n3. If you find an older date, update your 'oldest' memory\n4. If you find a newer date, update your 'newest' memory\n5. After checking all papers, you know both extremes\n\n<strong>Key insight:</strong> Unlike counting (where we use <code>elif</code>), min/max uses <em>separate</em> <code>if</code> statements because each item could update EITHER the min OR the max (or neither).\n\n<code>\n# Min/Max Pattern Example\noldest = dates[0]  # Start with first item\nnewest = dates[0]  # Both start the same\n\nfor date in dates:\n    if date < oldest:    # Check for new minimum\n        oldest = date\n    if date > newest:    # SEPARATE if, not elif!\n        newest = date\n</code>\n\n<em>Range checking with conditions:</em>\n‚Ä¢ Combine conditions: <code>if date >= 100 and date < 200:</code>\n‚Ä¢ Use elif for mutually exclusive ranges (a date can only be in ONE century)",
      "challenge": "Create functions to analyze fragment dating data and determine temporal distribution patterns.",
      "data": "Fragment dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]",
      "storyModifiers": {
        "technologyPath": {
          "additionalContext": "\n\nThe AI analysis returns shocking results: \"Language pattern identified. 87% probability: Modified Proto-Indo-European with mathematical notation embedded. This civilization encoded equations in their language structure!\"",
          "techDiscovery": "Each date corresponds to a astronomical event\u2014eclipses, planetary alignments"
        },
        "historicalPath": {
          "additionalContext": "\n\nYour historical research uncovers a pattern: \"Every date matches a documented crisis or disaster. 150 CE: Antonine Plague begins. 230 CE: Crisis of the Third Century. They were documenting catastrophes!\"",
          "historyDiscovery": "The fragments are a survival guide for future civilizations"
        }
      },
      "starterCode": "# Create functions to analyze fragment dating patterns\n# Dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\ndef find_date_range(dates):\n    # TODO: Initialize oldest and newest with the first date\n    # TODO: Loop through all dates to find min and max\n    # TODO: Return both values as a tuple\n    \n    return oldest_date, newest_date\n\ndef count_by_century(dates):\n    second_century = 0  # 100-199 CE\n    third_century = 0   # 200-299 CE\n    fourth_century = 0  # 300-399 CE\n    \n    # TODO: Loop through dates and categorize by century\n    # TODO: Use if/elif/else to count each century\n    # TODO: Return all three counts\n    \n    return second_century, third_century, fourth_century\n\n# Test your functions\ndates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\n# Analyze date range\noldest, newest = find_date_range(dates)\nprint(\"Date range: \" + str(oldest) + \" CE to \" + str(newest) + \" CE\")\nprint(\"Time span: \" + str(newest - oldest) + \" years\")\n\n# Analyze by century\nsecond, third, fourth = count_by_century(dates)\nprint(\"2nd century (100-199 CE): \" + str(second) + \" fragments\")\nprint(\"3rd century (200-299 CE): \" + str(third) + \" fragments\")\nprint(\"4th century (300-399 CE): \" + str(fourth) + \" fragments\")",
      "solution": "def find_date_range(dates):\n    oldest_date = dates[0]\n    newest_date = dates[0]\n    for date in dates:\n        if date < oldest_date:\n            oldest_date = date\n        if date > newest_date:\n            newest_date = date\n    return oldest_date, newest_date\n\ndef count_by_century(dates):\n    second_century = 0\n    third_century = 0\n    fourth_century = 0\n    for date in dates:\n        if date >= 100 and date < 200:\n            second_century += 1\n        elif date >= 200 and date < 300:\n            third_century += 1\n        elif date >= 300 and date < 400:\n            fourth_century += 1\n    return second_century, third_century, fourth_century\n\ndates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\noldest, newest = find_date_range(dates)\nprint(\"Date range: \" + str(oldest) + \" CE to \" + str(newest) + \" CE\")\nprint(\"Time span: \" + str(newest - oldest) + \" years\")\nsecond, third, fourth = count_by_century(dates)\nprint(\"2nd century (100-199 CE): \" + str(second) + \" fragments\")\nprint(\"3rd century (200-299 CE): \" + str(third) + \" fragments\")\nprint(\"4th century (300-399 CE): \" + str(fourth) + \" fragments\")",
      "validation": {
        "codePatterns": [
          "def\\s+\\w+\\s*\\(",
          "for\\s+\\w+\\s+in"
        ],
        "outputPatterns": [
          "150.*380|380.*150",
          "2.*century|second.*century",
          "3.*century|third.*century",
          "4.*century|fourth.*century"
        ],
        "flexible": true,
        "description": "Must create functions for date range analysis and century counting"
      },
      "hints": [
        "For min/max, you need a starting point. What's a reasonable initial value when you don't know what's in the list yet?",
        "As you loop through dates, you're asking: 'Is this older than my current oldest?' What comparison checks that?",
        "Unlike counting (where each item fits ONE category), a date might update the min, the max, or neither. How does that affect your if structure?",
        "For century counting, what range of years defines the 2nd century? The 3rd? The 4th? How do you express those as conditions?",
        "Both functions need to return multiple values. Check that your variables match what the return statement expects."
      ],
      "completionSegment": {
        "narrative": "The temporal analysis reveals a chilling pattern. Dr. Rodriguez stares at the results, her hands trembling slightly.\n\n\"230 years... That's not just a time span. That's almost exactly eight generations. In many ancient cultures, eight generations was considered a complete cycle of cultural memory.\"\n\n{{pathSpecificRevelation}}\n\nShe stands up abruptly. \"We need to make a decision. I've just received word that a team of 'private collectors' is heading to the Alexandria archives tomorrow. They're after the physical fragments.\"",
        "pathSpecificRevelations": {
          "technologyPath": "Your AI-enhanced analysis confirms it: 'The dates form a predictive model. The civilization was calculating future events. The next predicted date is... next month.'",
          "historicalPath": "Your historical research reveals the truth: 'They weren't just recording disasters\u2014they were recording successful responses to them. This is a survival manual.'"
        },
        "characterResponse": {
          "success": "\"Your date analysis is flawless. {{playerAction}} particularly impressed me\u2014you're thinking beyond the code to the meaning.\"",
          "struggle": "\"Dating analysis involves complex logic, and {{struggledConcept}} is a common challenge. But your persistence revealed something crucial.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez looks you straight in the eye. \"We can try to protect the fragments, or we can focus on decoding them before it's too late. What's your call?\"",
          "options": [
            {
              "id": "protect_fragments",
              "text": "Secure the physical fragments first",
              "consequence": "preservationPath",
              "preview": "Race to Alexandria to safeguard the artifacts",
              "addsUrgency": true
            },
            {
              "id": "decode_priority",
              "text": "Focus on decoding\u2014the information matters more than the artifacts",
              "consequence": "knowledgePath",
              "preview": "Let others chase fragments while we chase meaning",
              "addsComplexity": true
            }
          ]
        }
      }
    },
    {
      "id": 5,
      "title": "Word Frequency Analysis",
      "story": "You've transcribed some key words from the legible fragments. Analyzing word frequency might reveal important themes or repeated concepts in this ancient text.\n\n<strong>\ud83d\udd0d Python Concepts: Dictionary-like Counting and Functions</strong>\n\n<em>Functions</em> help organize data analysis tasks:\n\u2022 Define with <code>def function_name(parameters):</code>\n\u2022 Return structured data: <code>return counts_dict</code>\n\u2022 Functions make analysis reusable and clear\n\n<em>Counting with variables (simulating dictionary behavior):</em>\n\u2022 Use separate variables for each category\n\u2022 Compare strings with <code>==</code>: <code>if word == \"temple\":</code>\n\u2022 Increment counters: <code>temple_count += 1</code>\n\u2022 Track maximum values for analysis",
      "challenge": "Create a function to analyze word frequencies and identify the most common themes in the fragments.",
      "data": "Words found: [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]",
      "storyModifiers": {
        "preservationPath": {
          "additionalContext": "\n\nDr. Rodriguez messages from Alexandria: \"We secured the fragments just in time! But look at this\u2014hidden writing appears under UV light. These new words change everything!\"",
          "bonusWords": [
            "escape",
            "underground",
            "preservation",
            "future"
          ],
          "urgentNote": "Time pressure increases\u2014analyze quickly!"
        },
        "knowledgePath": {
          "additionalContext": "\n\nWhile others chase fragments, your deep analysis pays off: \"The word frequencies follow a mathematical pattern. It's not just what they're saying, but how often\u2014it's another layer of encoding!\"",
          "patternDiscovered": "Word frequency ratios: 4:3:3:2 = Musical intervals!",
          "insight": "They encoded music in their text frequency"
        }
      },
      "starterCode": "# Analyze word frequencies in the fragment text\n# Words: [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\ndef analyze_word_frequency(words):\n    \"\"\"Count occurrences of each key word.\n    \n    Args:\n        words: List of words from fragments\n        \n    Returns:\n        tuple: (temple_count, gold_count, sacred_count, ritual_count)\n    \"\"\"\n    temple_count = 0\n    gold_count = 0\n    sacred_count = 0\n    ritual_count = 0\n    \n    # TODO: Loop through words and count each type\n    # TODO: Use if/elif to check each word and increment counters\n    # TODO: Return all four counts\n    \n    return temple_count, gold_count, sacred_count, ritual_count\n\ndef find_most_common_word(temple_count, gold_count, sacred_count, ritual_count):\n    \"\"\"Find which word appears most frequently.\n    \n    Args:\n        temple_count, gold_count, sacred_count, ritual_count: Word counts\n        \n    Returns:\n        tuple: (most_common_word, highest_count)\n    \"\"\"\n    most_common_word = \"temple\"\n    highest_count = temple_count\n    \n    # TODO: Compare each count to find the highest\n    # TODO: Update most_common_word and highest_count when finding larger values\n    # TODO: Return the word and its count\n    \n    return most_common_word, highest_count\n\n# Test your functions\nwords = [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\n# Get word frequencies\ntemple, gold, sacred, ritual = analyze_word_frequency(words)\nprint(\"Word frequencies:\")\nprint(f\"  temple: {temple}\")\nprint(f\"  gold: {gold}\")\nprint(f\"  sacred: {sacred}\")\nprint(f\"  ritual: {ritual}\")\n\n# Find most common\nword, count = find_most_common_word(temple, gold, sacred, ritual)\nprint(f\"Most common word: {word} ({count} occurrences)\")",
      "solution": "# Analyze word frequencies in the fragment text\n\ndef analyze_word_frequency(words):\n    \"\"\"Count occurrences of each key word.\"\"\"\n    temple_count = 0\n    gold_count = 0\n    sacred_count = 0\n    ritual_count = 0\n    \n    for word in words:\n        if word == \"temple\":\n            temple_count += 1\n        elif word == \"gold\":\n            gold_count += 1\n        elif word == \"sacred\":\n            sacred_count += 1\n        elif word == \"ritual\":\n            ritual_count += 1\n    \n    return temple_count, gold_count, sacred_count, ritual_count\n\ndef find_most_common_word(temple_count, gold_count, sacred_count, ritual_count):\n    \"\"\"Find which word appears most frequently.\"\"\"\n    most_common_word = \"temple\"\n    highest_count = temple_count\n    \n    if gold_count > highest_count:\n        most_common_word = \"gold\"\n        highest_count = gold_count\n    if sacred_count > highest_count:\n        most_common_word = \"sacred\"\n        highest_count = sacred_count\n    if ritual_count > highest_count:\n        most_common_word = \"ritual\"\n        highest_count = ritual_count\n    \n    return most_common_word, highest_count\n\n# Test the functions\nwords = [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\n# Get word frequencies\ntemple, gold, sacred, ritual = analyze_word_frequency(words)\nprint(\"Word frequencies:\")\nprint(f\"  temple: {temple}\")\nprint(f\"  gold: {gold}\")\nprint(f\"  sacred: {sacred}\")\nprint(f\"  ritual: {ritual}\")\n\n# Find most common\nword, count = find_most_common_word(temple, gold, sacred, ritual)\nprint(f\"Most common word: {word} ({count} occurrences)\")",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_word_frequency\\s*\\(",
          "def\\s+find_most_common_word\\s*\\(",
          "for\\s+\\w+\\s+in"
        ],
        "outputPatterns": [
          "temple.*4|4.*temple",
          "gold.*3|3.*gold",
          "sacred.*3|3.*sacred",
          "ritual.*2|2.*ritual"
        ],
        "requiredNumbers": [4, 3, 3, 2],
        "flexible": true,
        "description": "Must create functions for word frequency analysis and finding maximum"
      },
      "hints": [
        "The word frequency function loops through words. For each word, what question are you asking?",
        "You're comparing strings. What operator checks if two strings are exactly the same?",
        "The second function receives four counts. How do you find which one is largest?",
        "When you find a new maximum, you need to remember both the word AND its count. Why both?",
        "Think about initializing: if you start with temple as the assumed maximum, what happens if another word has more occurrences?"
      ],
      "completionSegment": {
        "narrative": "The word frequency analysis completes, and suddenly the pattern becomes crystal clear. Dr. Rodriguez gasps.\n\n\"Temple, gold, sacred, ritual... This isn't religious text. It's instructions! They're describing how to preserve knowledge using temple gold\u2014a metal that doesn't corrode\u2014inscribed with sacred rituals that ensure the knowledge is maintained.\"\n\n{{pathSpecificInsight}}\n\n\"We're close to understanding their complete message. But I need to share something with you...\" Dr. Rodriguez looks uncomfortable. \"I haven't been entirely honest about how I found these fragments.\"",
        "pathSpecificInsights": {
          "preservationPath": "The UV-revealed words confirm it: 'escape,' 'underground,' 'preservation'\u2014they were fleeing something catastrophic and left instructions for survivors!",
          "knowledgePath": "The musical encoding in the frequencies isn't decorative\u2014it's functional. When the frequencies are played as notes, they form a mathematical sequence that unlocks the next layer of the cipher!"
        },
        "characterResponse": {
          "success": "\"Your frequency analysis is brilliant! {{playerAction}} revealed exactly what we needed. You have a natural talent for pattern recognition.\"",
          "struggle": "\"Frequency analysis requires careful tracking, and {{struggledConcept}} added complexity. But you found the pattern that unlocks everything.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez takes a deep breath. \"I found these fragments because... I was following clues left by my grandmother. She was part of a society that's been protecting this knowledge for generations. Now I need to know\u2014can I trust you with the complete truth?\"",
          "options": [
            {
              "id": "demand_truth",
              "text": "I need to know everything before we continue",
              "consequence": "truthPath",
              "preview": "Insist on full disclosure about the secret society",
              "revealsBackstory": true
            },
            {
              "id": "trust_rodriguez",
              "text": "Your grandmother's legacy is safe with me\u2014let's finish this together",
              "consequence": "trustPath",
              "preview": "Build alliance based on mutual trust",
              "strengthensRelationship": true
            }
          ]
        }
      }
    },
    {
      "id": 6,
      "title": "Fragment Reconstruction",
      "story": "Some fragments appear to be parts of the same document. By analyzing character patterns and common sequences, you can identify which fragments belong together.\n\nDr. Rodriguez's voice crackles over the secure channel: \"The Keepers left us another clue. My grandmother's journals mention that the Bridge Builders didn't just write randomly‚Äîthey created chains of thought, where one fragment's ending connects to another's beginning. Like links in a chain of knowledge.\"\n\n<strong>üîç Python Concepts: String Methods and Boolean Logic</strong>\n\n<em>STRING METHODS</em> - Examining text programmatically:\nThink of strings as beads on a necklace. Python gives us tools to examine any bead:\n\n‚Ä¢ <code>.startswith(prefix)</code> - Does the string begin with this text?\n  <code>\"The temple\".startswith(\"The\")  # True</code>\n  <code>\"temple was\".startswith(\"The\")   # False</code>\n\n‚Ä¢ <code>.endswith(suffix)</code> - Does the string end with this text?\n  <code>\"sacred temple\".endswith(\"temple\")  # True</code>\n\n‚Ä¢ <code>in</code> keyword - Is this text anywhere inside?\n  <code>\"temple\" in \"The sacred temple\"  # True</code>\n  <code>\"gold\" in \"The sacred temple\"    # False</code>\n\n‚Ä¢ <code>.split()</code> - Break text into a list of words:\n  <code>\"hello world\".split()  # [\"hello\", \"world\"]</code>\n  <code>words = text.split(); last_word = words[-1]</code>\n\n<em>BOOLEAN LOGIC</em> - Combining conditions:\n‚Ä¢ <code>and</code> - Both must be true: <code>if has_temple and has_gold:</code>\n‚Ä¢ <code>or</code> - Either can be true: <code>if is_latin or is_greek:</code>\n‚Ä¢ <code>not</code> - Inverts the condition: <code>if not is_damaged:</code>",
      "challenge": "Analyze fragments to find matching patterns and group related pieces together.",
      "data": "Fragment texts: [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]",
      "storyModifiers": {
        "truthPath": {
          "additionalContext": "\n\nDr. Rodriguez reveals: \"The society is called the Keepers of Alexandria. For 1,700 years, we've been waiting for someone with the skills to decode these fragments. My grandmother believed that person would emerge when the world needed this knowledge most.\"",
          "societySecret": "The Keepers have fragments hidden in 12 locations worldwide",
          "responsibility": "You're now being invited to join the Keepers"
        },
        "trustPath": {
          "additionalContext": "\n\nDr. Rodriguez smiles with relief: \"Your trust means everything. Together, we can finish what my grandmother started. She left me one final clue\u2014a fragment she kept hidden that connects all the others.\"",
          "hiddenFragment": "The master key: 'When temple gold preserves the sacred ritual, time's spiral completes'",
          "bond": "Dr. Rodriguez now fully trusts you as a partner"
        }
      },
      "starterCode": "# Fragment Reconstruction - Group related fragments together\n# Fragments: [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]\n\nfragments = [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]\n\n# Task 1: Group fragments by common keywords\nprint(\"=== GROUPING FRAGMENTS BY KEYWORD ===\")\n\n# TODO: Loop through fragments and check for keywords\n# TODO: Print fragments that contain \"temple\"\n# TODO: Print fragments that contain \"times\"\n# TODO: Print fragments that contain \"altar\"\n\n# Task 2: Find connected fragments (where one ends with a word another starts with)\nprint(\"\\n=== FINDING CONNECTED FRAGMENTS ===\")\n\n# TODO: Use nested loops to compare fragments\n# TODO: Get the last word of one fragment and first word of another\n# TODO: Print connections when they match",
      "solution": "# Fragment Reconstruction - Group related fragments together\n\nfragments = [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]\n\n# Task 1: Group fragments by common keywords\nprint(\"=== GROUPING FRAGMENTS BY KEYWORD ===\")\n\nprint(\"\\nTemple fragments:\")\nfor fragment in fragments:\n    if \"temple\" in fragment:\n        print(f\"  - {fragment}\")\n\nprint(\"\\nTimes fragments:\")\nfor fragment in fragments:\n    if \"times\" in fragment:\n        print(f\"  - {fragment}\")\n\nprint(\"\\nAltar fragments:\")\nfor fragment in fragments:\n    if \"altar\" in fragment:\n        print(f\"  - {fragment}\")\n\n# Task 2: Find connected fragments\nprint(\"\\n=== FINDING CONNECTED FRAGMENTS ===\")\n\nfor i in range(len(fragments)):\n    for j in range(len(fragments)):\n        if i != j:\n            words_i = fragments[i].split()\n            words_j = fragments[j].split()\n            last_word = words_i[-1].lower()\n            first_word = words_j[0].lower()\n            if last_word == first_word:\n                print(f\"Connection found: '{fragments[i]}' -> '{fragments[j]}'\")",
      "validation": {
        "codePatterns": [
          "for\\s+\\w+\\s+in",
          "in\\s+fragment|fragment.*in"
        ],
        "outputPatterns": [
          "[Tt]emple.*sacred|sacred.*[Tt]emple",
          "[Tt]imes.*ancient|ancient.*[Tt]imes",
          "[Aa]ltar.*golden|golden.*[Aa]ltar"
        ],
        "flexible": true,
        "description": "Must group fragments by common words and find connections"
      },
      "hints": [
        "To find fragments containing 'temple', what keyword checks if one string is inside another?",
        "For Task 2, you need to compare the END of one fragment with the START of another. How do you get individual words from a string?",
        "When you split a string into words, how do you access the last word? The first word?",
        "You're comparing every fragment to every other fragment. What loop structure lets you do that?",
        "Be careful not to compare a fragment with itself! How do you skip that case?"
      ],
      "completionSegment": {
        "narrative": "The reconstruction algorithm reveals the fragments' true structure. They connect in a specific sequence, forming a larger message. Dr. Rodriguez's eyes fill with tears.\n\n\"It's beautiful. They didn't just preserve knowledge‚Äîthey created a system that would only reveal itself to someone who understood both ancient languages AND modern programming. They predicted the rise of computational analysis!\"\n\nShe pulls out a worn photograph from her wallet‚Äîa young girl sitting on an elderly woman's lap, both holding fragments of ancient-looking paper. \"That's me and my grandmother, thirty years ago. She used to tell me bedtime stories about the Bridge Builders. I thought they were just fairy tales until I found her research notes after she passed.\"\n\n{{pathSpecificRevelation}}\n\nThe reconstructed message begins to glow on your screen, quite literally‚Äîthe code is triggering something in the display system.",
        "pathSpecificRevelations": {
          "truthPath": "As a potential Keeper, you now see the hidden layer: The fragments contain quantum entanglement patterns. This ancient civilization understood principles we're only now discovering!",
          "trustPath": "The master fragment Dr. Rodriguez shared completes the puzzle: The message is a blueprint for a device that preserves information across millennia using crystallized gold structures."
        },
        "characterResponse": {
          "success": "\"Your string manipulation is elegant! {{playerAction}} shows mastery of both the technical and interpretive skills needed for digital archaeology. My grandmother would have loved working with you.\"",
          "struggle": "\"String operations and {{struggledConcept}} can be challenging, but you've reconstructed something that's been broken for nearly two thousand years! That takes real persistence.\""
        },
        "choice": {
          "prompt": "The screen flashes with an urgent message: 'COMPLETE ACTIVATION SEQUENCE? This action will broadcast the decoded knowledge globally. Proceed?'",
          "options": [
            {
              "id": "activate_broadcast",
              "text": "Yes\u2014share this knowledge with humanity",
              "consequence": "enlightenmentPath",
              "preview": "Release ancient wisdom to the world",
              "globalImpact": true
            },
            {
              "id": "secure_knowledge",
              "text": "No\u2014this needs to be studied carefully first",
              "consequence": "guardianPath",
              "preview": "Protect knowledge until humanity is ready",
              "createsResponsibility": true
            }
          ]
        }
      }
    },
    {
      "id": 7,
      "title": "Geographic Distribution",
      "story": "The fragments were found at different archaeological sites. Understanding their geographic distribution might reveal trade routes or cultural connections.\n\nDr. Rodriguez shares her screen, showing a map dotted with excavation sites. \"My grandmother marked these locations years ago, but she never had the computational tools to analyze them properly. She'd be amazed to see what we can do now.\"\n\n<strong>üîç Python Concepts: Functions, Parallel Lists, and Statistical Analysis</strong>\n\n<em>PERCENTAGE CALCULATIONS</em> - Understanding proportions:\nPercentages help us compare values of different sizes. The formula is:\n<code>percentage = (part / whole) * 100</code>\n\nExample: If Alexandria has 15 fragments out of 40 total:\n<code>percentage = (15 / 40) * 100  # = 37.5%</code>\n\nUse <code>round(value, decimal_places)</code> to clean up decimals:\n<code>round(37.512345, 1)  # = 37.5</code>\n\n<em>PARALLEL LISTS</em> - Related data in separate lists:\nWhen you have matching data (site names and their counts), keep them in parallel lists and access both using the same index:\n<code>\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\"]\ncounts = [15, 8, 12]\n\nfor i in range(len(sites)):\n    print(f\"{sites[i]}: {counts[i]} fragments\")\n</code>\n\n<em>THE <code>sum()</code> FUNCTION</em> - Add up a list quickly:\n<code>total = sum([15, 8, 12, 5])  # = 40</code>",
      "challenge": "Create functions to analyze geographic distribution and calculate site statistics.",
      "data": "Sites: [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\nFragment counts: [15, 8, 12, 5]",
      "storyModifiers": {
        "enlightenmentPath": {
          "additionalContext": "\n\nThe global broadcast has begun. Responses are pouring in from archaeological sites worldwide: 'We have matching fragments!' The puzzle is bigger than anyone imagined\u2014this civilization left messages across the entire ancient world!",
          "worldResponse": "UNESCO declares this the most significant archaeological discovery in human history",
          "newSites": [
            "Rome",
            "Athens",
            "Carthage",
            "Babylon",
            "Persepolis"
          ]
        },
        "guardianPath": {
          "additionalContext": "\n\nYou've chosen the path of wisdom. But others have detected the activation prompt. Multiple parties are converging on your location, all wanting the knowledge for different purposes.",
          "threats": [
            "Corporate data miners",
            "Government agencies",
            "Treasure hunters"
          ],
          "allies": "The Keepers of Alexandria stand ready to help protect the knowledge"
        }
      },
      "starterCode": "# Geographic Distribution Analysis\n# Sites: [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\n# Fragment counts: [15, 8, 12, 5]\n\ndef calculate_site_statistics(sites, counts):\n    \"\"\"Calculate statistics for each site.\n    \n    Args:\n        sites: List of site names\n        counts: List of fragment counts (parallel to sites)\n        \n    Returns:\n        tuple: (total_fragments, site_statistics list)\n        Each site_statistics entry: (site_name, count, percentage)\n    \"\"\"\n    total_fragments = sum(counts)\n    site_statistics = []\n    \n    # TODO: Loop through sites using range(len(sites))\n    # TODO: Calculate percentage for each site: (counts[i] / total_fragments) * 100\n    # TODO: Append (sites[i], counts[i], percentage) to site_statistics\n    # TODO: Return total_fragments and site_statistics\n    \n    return total_fragments, site_statistics\n\ndef find_major_sites(sites, counts, threshold):\n    \"\"\"Find sites with fragment counts >= threshold.\n    \n    Args:\n        sites: List of site names\n        counts: List of fragment counts\n        threshold: Minimum count to be considered major\n        \n    Returns:\n        tuple: (top_site, top_count, major_sites list)\n    \"\"\"\n    top_site = sites[0]\n    top_count = counts[0]\n    major_sites = []\n    \n    # TODO: Loop through sites to find the one with most fragments\n    # TODO: Also collect all sites that meet the threshold\n    # TODO: Return top_site, top_count, and major_sites list\n    \n    return top_site, top_count, major_sites\n\n# Test your functions\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\ncounts = [15, 8, 12, 5]\n\n# Calculate statistics\ntotal, stats = calculate_site_statistics(sites, counts)\nprint(f\"Total fragments discovered: {total}\")\nprint(\"\\nSite breakdown:\")\nfor site_name, count, pct in stats:\n    print(f\"  {site_name}: {count} fragments ({pct}%)\")\n\n# Find major sites (threshold: 10 fragments)\ntop, top_count, major = find_major_sites(sites, counts, 10)\nprint(f\"\\nMost fragments found at: {top} ({top_count})\")\nprint(f\"Major sites (>=10 fragments): {len(major)} sites\")\nfor site in major:\n    print(f\"  - {site}\")",
      "solution": "# Geographic Distribution Analysis\n\ndef calculate_site_statistics(sites, counts):\n    \"\"\"Calculate statistics for each site.\"\"\"\n    total_fragments = sum(counts)\n    site_statistics = []\n    \n    for i in range(len(sites)):\n        percentage = round((counts[i] / total_fragments) * 100, 1)\n        site_statistics.append((sites[i], counts[i], percentage))\n    \n    return total_fragments, site_statistics\n\ndef find_major_sites(sites, counts, threshold):\n    \"\"\"Find sites with fragment counts >= threshold.\"\"\"\n    top_site = sites[0]\n    top_count = counts[0]\n    major_sites = []\n    \n    for i in range(len(sites)):\n        if counts[i] > top_count:\n            top_site = sites[i]\n            top_count = counts[i]\n        if counts[i] >= threshold:\n            major_sites.append(sites[i])\n    \n    return top_site, top_count, major_sites\n\n# Test the functions\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\ncounts = [15, 8, 12, 5]\n\n# Calculate statistics\ntotal, stats = calculate_site_statistics(sites, counts)\nprint(f\"Total fragments discovered: {total}\")\nprint(\"\\nSite breakdown:\")\nfor site_name, count, pct in stats:\n    print(f\"  {site_name}: {count} fragments ({pct}%)\")\n\n# Find major sites (threshold: 10 fragments)\ntop, top_count, major = find_major_sites(sites, counts, 10)\nprint(f\"\\nMost fragments found at: {top} ({top_count})\")\nprint(f\"Major sites (>=10 fragments): {len(major)} sites\")\nfor site in major:\n    print(f\"  - {site}\")",
      "validation": {
        "codePatterns": [
          "def\\s+calculate_site_statistics\\s*\\(",
          "def\\s+find_major_sites\\s*\\(",
          "for\\s+\\w+\\s+in\\s+range"
        ],
        "outputPatterns": [
          "40|total.*40",
          "Alexandria.*15|15.*Alexandria",
          "Memphis.*8|8.*Memphis",
          "Thebes.*12|12.*Thebes"
        ],
        "requiredNumbers": [40, 15, 8, 12, 5],
        "flexible": true,
        "description": "Must create functions for geographic analysis with parallel lists and statistics"
      },
      "hints": [
        "To calculate percentages, you first need the total. What function adds up all numbers in a list?",
        "You have two parallel lists: sites and counts. How do you access matching pairs? (Think about using an index)",
        "The percentage formula is (part / whole) * 100. What values do you plug in for each site?",
        "Percentages can have many decimal places. What function rounds a number to a specific number of decimal places?",
        "For major sites, you're building a new list of sites that meet a condition. What method adds an item to a list?"
      ],
      "completionSegment": {
        "narrative": "The geographic analysis reveals a stunning truth. The sites form a perfect geometric pattern when plotted on a map‚Äîa pentagram with Alexandria at its heart.\n\nDr. Rodriguez pulls up an ancient star chart, her hands trembling slightly. \"These sites align with the constellation Draco as it appeared in 250 CE. They built a map of the heavens on Earth!\"\n\nShe's quiet for a moment, staring at the screen. \"My grandmother spent forty years mapping these locations by hand. Forty years of train tickets, dusty archives, and letters to colleagues who thought she was chasing fantasies.\" Her voice catches. \"She died six months before GPS satellites could have confirmed her work in seconds.\"\n\n{{pathSpecificDevelopment}}\n\nDr. Rodriguez straightens, her resolve renewed. \"We're approaching the culmination of everything we've discovered. My grandmother's work, the Bridge Builders' legacy, your skills‚Äîthey're all converging. The final stage will require everything you've learned.\"",
        "pathSpecificDevelopments": {
          "enlightenmentPath": "The worldwide revelation has triggered something unexpected: Ancient sites across the globe are resonating with electromagnetic energy. The fragments weren't just messages\u2014they're components of a planetary-scale device!",
          "guardianPath": "Your decision to protect the knowledge has paid off. The Keepers reveal that each site contains a hidden chamber with more fragments. But you must choose which site to excavate first, knowing others are watching."
        },
        "characterResponse": {
          "success": "\"Your geographic analysis is masterful! {{playerAction}} particularly‚Äîyou've revealed a pattern my grandmother spent decades trying to prove. She knew someone would finish what she started.\"",
          "struggle": "\"Geographic data analysis with {{struggledConcept}} is complex, but you've uncovered the celestial connection we needed. That persistence‚Äîthat's what separates researchers from tourists.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez shows you the final piece of the puzzle: 'The geographic pattern points to a central location we haven't excavated yet\u2014a place where all the knowledge converges. But reaching it means making a choice about how this story ends.'",
          "options": [
            {
              "id": "seek_source",
              "text": "Journey to the convergence point immediately",
              "consequence": "discoveryEnding",
              "preview": "Race to uncover the source of all fragments",
              "leadsToEnding": "seeker"
            },
            {
              "id": "protect_sites",
              "text": "Secure all known sites before proceeding",
              "consequence": "guardianEnding",
              "preview": "Ensure the knowledge is preserved for future generations",
              "leadsToEnding": "guardian"
            },
            {
              "id": "share_coordinates",
              "text": "Publish the convergence point coordinates for all humanity",
              "consequence": "enlightenmentEnding",
              "preview": "Let the world join in the final discovery",
              "leadsToEnding": "savior"
            }
          ]
        }
      }
    },
    {
      "id": 8,
      "title": "Digital Restoration",
      "story": "Using digital imaging techniques, you've recovered some damaged text. The restoration process involves analyzing character patterns and filling in gaps based on context.\n\nDr. Rodriguez looks exhausted but determined. \"This is the moment my grandmother dreamed of. She used to sit with damaged scrolls for months, using magnifying glasses and intuition. She always said, 'Elena, someday computers will help us see what time has hidden.' I just wish she could see this.\"\n\n<strong>üîç Python Concepts: String Processing and Systematic Replacement</strong>\n\n<em>STRING REPLACEMENT</em> - Fixing damaged text:\nThe <code>.replace(old, new)</code> method swaps text:\n<code>\"h?llo\".replace(\"?\", \"e\")  # \"hello\"</code>\n\nChain replacements for multiple fixes:\n<code>\ntext = \"th? s?cr?d\"\nstep1 = text.replace(\"th?\", \"the\")\nstep2 = step1.replace(\"s?cr?d\", \"sacred\")\n# Result: \"the sacred\"\n</code>\n\n<em>TEXT ANALYSIS</em>:\n‚Ä¢ <code>.count(substring)</code> - How many times does this appear?\n  <code>\"hello\".count(\"l\")  # 2</code>\n‚Ä¢ <code>len(text)</code> - Total character count\n‚Ä¢ <code>.capitalize()</code> - Uppercase first letter",
      "challenge": "Create functions to systematically restore damaged text and calculate restoration statistics.",
      "data": "Damaged text: \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"",
      "storyModifiers": {
        "discoveryEnding": {
          "additionalContext": "\n\nYou're racing against time to the convergence point. Your restoration algorithm will be crucial\u2014the final message is heavily damaged, and only perfect restoration will reveal the ultimate truth.",
          "pressure": "Other parties are hours behind you",
          "stakes": "First to decode wins everything"
        },
        "guardianEnding": {
          "additionalContext": "\n\nAs you secure each site, you find more damaged texts. Your restoration work is preserving knowledge that would otherwise be lost forever. The Keepers are documenting everything.",
          "legacy": "Your methods will teach future generations",
          "responsibility": "You're becoming the knowledge keeper"
        },
        "enlightenmentEnding": {
          "additionalContext": "\n\nThe world watches as you restore the damaged text live. Millions are following your code, learning both programming and archaeology. You're not just revealing history\u2014you're teaching it.",
          "audience": "Global livestream with 100 million viewers",
          "impact": "Inspiring a new generation of digital archaeologists"
        }
      },
      "starterCode": "# Digital Restoration - Repair damaged ancient text\n# Damaged text: \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n# The '?' characters represent damaged/illegible characters\n\ndef analyze_damage(text):\n    \"\"\"Analyze the damage level of the text.\n    \n    Args:\n        text: The damaged text string\n        \n    Returns:\n        tuple: (total_chars, damaged_chars, damage_percentage)\n    \"\"\"\n    total_chars = len(text)\n    damaged_chars = text.count(\"?\")\n    \n    # TODO: Calculate the damage percentage\n    # TODO: Return all three values\n    \n    return total_chars, damaged_chars, damage_percentage\n\ndef restore_text(damaged_text):\n    \"\"\"Restore the damaged text by replacing damaged characters.\n    \n    Known patterns to restore:\n    - 'th?' -> 'the'\n    - 's?cr?d' -> 'sacred'\n    - 't?mpl?' -> 'temple'\n    - 'w?s' -> 'was'\n    - 'b??lt' -> 'built'\n    - '?n' -> 'in'\n    - '?nc??nt' -> 'ancient'\n    - 't?m?s' -> 'times'\n    \n    Args:\n        damaged_text: The text with '?' for damaged characters\n        \n    Returns:\n        tuple: (restored_text, restoration_steps)\n    \"\"\"\n    # TODO: Apply replacements step by step\n    # TODO: Count how many replacement operations you perform\n    # TODO: Capitalize the first letter at the end\n    # TODO: Return the final text and step count\n    \n    return final_text, total_steps\n\n# Test your functions\ndamaged = \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n\nprint(\"=== DIGITAL RESTORATION ANALYSIS ===\")\nprint(f\"Original damaged text: {damaged}\")\n\n# Analyze damage\ntotal, damaged_count, pct = analyze_damage(damaged)\nprint(f\"\\nTotal characters: {total}\")\nprint(f\"Damaged characters: {damaged_count}\")\nprint(f\"Damage level: {pct}%\")\n\n# Restore text\nrestored, steps = restore_text(damaged)\nprint(f\"\\nRestoration complete in {steps} steps\")\nprint(f\"Final restored text: {restored}\")\nprint(f\"Text length: {len(damaged)} -> {len(restored)}\")\nprint(f\"Characters restored: {damaged_count}\")",
      "solution": "# Digital Restoration - Repair damaged ancient text\n\ndef analyze_damage(text):\n    \"\"\"Analyze the damage level of the text.\"\"\"\n    total_chars = len(text)\n    damaged_chars = text.count(\"?\")\n    damage_percentage = round((damaged_chars / total_chars) * 100, 1)\n    \n    return total_chars, damaged_chars, damage_percentage\n\ndef restore_text(damaged_text):\n    \"\"\"Restore the damaged text by replacing damaged characters.\"\"\"\n    total_steps = 0\n    \n    # Apply restorations step by step\n    step1 = damaged_text.replace(\"th?\", \"the\")\n    total_steps += 1\n    \n    step2 = step1.replace(\"s?cr?d\", \"sacred\")\n    total_steps += 1\n    \n    step3 = step2.replace(\"t?mpl?\", \"temple\")\n    total_steps += 1\n    \n    step4 = step3.replace(\"w?s\", \"was\")\n    total_steps += 1\n    \n    step5 = step4.replace(\"b??lt\", \"built\")\n    total_steps += 1\n    \n    step6 = step5.replace(\"?n\", \"in\")\n    total_steps += 1\n    \n    step7 = step6.replace(\"?nc??nt\", \"ancient\")\n    total_steps += 1\n    \n    step8 = step7.replace(\"t?m?s\", \"times\")\n    total_steps += 1\n    \n    # Capitalize first letter\n    final_text = step8.capitalize()\n    \n    return final_text, total_steps\n\n# Test the functions\ndamaged = \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n\nprint(\"=== DIGITAL RESTORATION ANALYSIS ===\")\nprint(f\"Original damaged text: {damaged}\")\n\n# Analyze damage\ntotal, damaged_count, pct = analyze_damage(damaged)\nprint(f\"\\nTotal characters: {total}\")\nprint(f\"Damaged characters: {damaged_count}\")\nprint(f\"Damage level: {pct}%\")\n\n# Restore text\nrestored, steps = restore_text(damaged)\nprint(f\"\\nRestoration complete in {steps} steps\")\nprint(f\"Final restored text: {restored}\")\nprint(f\"Text length: {len(damaged)} -> {len(restored)}\")\nprint(f\"Characters restored: {damaged_count}\")",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_damage\\s*\\(",
          "def\\s+restore_text\\s*\\(",
          "\\.replace\\("
        ],
        "outputPatterns": [
          "42|total.*42",
          "13|damaged.*13",
          "[Tt]he sacred temple was built in ancient times"
        ],
        "requiredNumbers": [42, 13],
        "requiredText": ["sacred temple", "ancient times"],
        "flexible": true,
        "description": "Must create functions for text restoration with damage analysis and systematic replacement"
      },
      "hints": [
        "The damaged characters are all '?' symbols. What string method counts how many times something appears?",
        "Damage percentage is (damaged / total) * 100. You have both counts‚Äîwhat goes where?",
        "Each .replace() call returns a NEW string with the replacement made. How do you chain multiple replacements?",
        "The replacement order might matter. If one pattern contains another, which should you replace first?",
        "After all replacements, the text should start with a capital letter. What method capitalizes the first character?"
      ],
      "completionSegment": {
        "narrative": "The restoration completes perfectly. The ancient text reveals its final secret:\n\n'The sacred temple was built in ancient times... to preserve the echo of stars, the memory of mathematics, the soul of science. We are the Bridge Builders, connecting past to future. Our civilization ends, but our knowledge endures. To you who can read this: you are our descendants, not in blood, but in mind. Build your own bridges.'\n\n{{pathSpecificClimax}}\n\nDr. Rodriguez turns to you, tears streaming down her face. \"We did it. We actually did it.\"\n\nShe takes a shaky breath. \"When I was twelve, my grandmother gave me a locket. Inside was a tiny fragment of papyrus with five words I never understood until now: 'Build your own bridges, Elena.' She knew. Somehow, she always knew I'd be here, finishing what she started.\"\n\nShe opens the locket to show you‚Äîthe papyrus is real, the handwriting ancient.",
        "pathSpecificClimaxes": {
          "discoveryEnding": "At the convergence point, your restored text activates an ancient device. A holographic library materializes\u2014containing the complete knowledge of the lost civilization. You stand in awe as centuries of wisdom unfold before you.",
          "guardianEnding": "Your careful preservation ensures the knowledge survives. The Keepers make you their new leader, entrusting you with fragments from around the world. You'll spend your life protecting and sharing this wisdom.",
          "enlightenmentEnding": "As millions watch your restoration, something miraculous happens: People worldwide begin finding new fragments, inspired by your work. The ancient civilization's dream is realized\u2014their knowledge truly belongs to all humanity."
        },
        "characterResponse": {
          "success": "\"Your restoration algorithm is perfect! {{playerAction}} brought ancient words back to life. My grandmother spent her whole life hoping someone would read these words again. Because of you, her hope wasn't in vain.\"",
          "struggle": "\"Text restoration and {{struggledConcept}} pushed your skills to the limit, but you've achieved something my grandmother dreamed of her whole life‚Äîyou've given voice to the past.\""
        }
      }
    },
    {
      "id": 9,
      "title": "The Final Revelation",
      "story": "All your analysis has led to this moment. By combining the data from all previous stages, you can now piece together the complete story of this ancient civilization.\n\nDr. Rodriguez sits beside you, unusually quiet. Finally, she speaks: \"Before we begin this final step, I want you to know something. When I started this project five years ago, I was alone. Colleagues dismissed my research. Funding dried up. There were nights I almost gave up.\"\n\nShe looks at you with gratitude. \"Then you came along‚Äîsomeone who understood that code can be archaeology, that algorithms can unearth history. Whatever happens next, we've already succeeded. We've proven that the Bridge Builders were right: knowledge finds a way.\"\n\n<strong>üîç Python Concepts: Bringing It All Together</strong>\n\nSynthesizing your skills:\n‚Ä¢ Variables and data types (Stage 1)\n‚Ä¢ Lists and loops (Stage 2)\n‚Ä¢ Conditionals and functions (Stages 3-5)\n‚Ä¢ String methods (Stage 6)\n‚Ä¢ Parallel lists and percentages (Stage 7)\n‚Ä¢ Text processing (Stage 8)\n\nThis final challenge asks you to create a comprehensive report using ALL these skills‚Äîproving you've become the computational archaeologist the Bridge Builders predicted.",
      "challenge": "Create a final analysis report using the summary data below. Calculate the total fragments, find the most common language, and identify the primary time period.",
      "data": "Summary data from all investigations:\n\nfragments_by_site = {\"Alexandria\": 15, \"Memphis\": 8, \"Thebes\": 12, \"Aswan\": 5}\nlanguage_counts = {\"Latin\": 5, \"Greek\": 3, \"Unknown\": 4}\ncentury_counts = {\"2nd\": 3, \"3rd\": 4, \"4th\": 3}\nkey_words = [\"temple\", \"sacred\", \"gold\", \"ritual\"]",
      "starterCode": "# Final Analysis Report\n# Summary data from all investigations\n\nfragments_by_site = {\"Alexandria\": 15, \"Memphis\": 8, \"Thebes\": 12, \"Aswan\": 5}\nlanguage_counts = {\"Latin\": 5, \"Greek\": 3, \"Unknown\": 4}\ncentury_counts = {\"2nd\": 3, \"3rd\": 4, \"4th\": 3}\nkey_words = [\"temple\", \"sacred\", \"gold\", \"ritual\"]\n\n# Task 1: Calculate total fragments across all sites\ntotal_fragments = 0\nfor site in fragments_by_site:\n    total_fragments = total_fragments + fragments_by_site[site]\n\nprint(\"=== FINAL ANALYSIS REPORT ===\")\nprint(\"Total fragments analyzed: \" + str(total_fragments))\n\n# Task 2: Find the site with the most fragments\n# TODO: Loop through fragments_by_site to find the site with highest count\n# Hint: Track the max count and the site name as you loop\n\n# Task 3: Find the most common language\n# TODO: Loop through language_counts to find the most common language\n\n# Task 4: Print the key words\nprint(\"Key themes discovered: \" + \", \".join(key_words))\n\nprint(\"=== END OF REPORT ===\")",
      "solution": "# Final Analysis Report\nfragments_by_site = {\"Alexandria\": 15, \"Memphis\": 8, \"Thebes\": 12, \"Aswan\": 5}\nlanguage_counts = {\"Latin\": 5, \"Greek\": 3, \"Unknown\": 4}\ncentury_counts = {\"2nd\": 3, \"3rd\": 4, \"4th\": 3}\nkey_words = [\"temple\", \"sacred\", \"gold\", \"ritual\"]\n\n# Task 1: Calculate total fragments\ntotal_fragments = 0\nfor site in fragments_by_site:\n    total_fragments = total_fragments + fragments_by_site[site]\n\nprint(\"=== FINAL ANALYSIS REPORT ===\")\nprint(\"Total fragments analyzed: \" + str(total_fragments))\n\n# Task 2: Find site with most fragments\nmax_count = 0\ntop_site = \"\"\nfor site in fragments_by_site:\n    if fragments_by_site[site] > max_count:\n        max_count = fragments_by_site[site]\n        top_site = site\nprint(\"Primary excavation site: \" + top_site + \" (\" + str(max_count) + \" fragments)\")\n\n# Task 3: Find most common language\nmax_lang_count = 0\ntop_language = \"\"\nfor lang in language_counts:\n    if language_counts[lang] > max_lang_count:\n        max_lang_count = language_counts[lang]\n        top_language = lang\nprint(\"Dominant language: \" + top_language)\n\n# Task 4: Key words\nprint(\"Key themes discovered: \" + \", \".join(key_words))\n\nprint(\"=== END OF REPORT ===\")",
      "validation": {
        "codePatterns": [
          "for\\s+\\w+\\s+in"
        ],
        "outputPatterns": [
          "(40|Total.*40|fragments.*40)",
          "(Alexandria|primary|Primary)",
          "(Latin|language|Language)"
        ],
        "description": "Must calculate totals and find maximums from the data"
      },
      "hints": [
        "Total fragments: Loop through fragments_by_site and add up all the values",
        "To find max: Track the current maximum and update when you find a larger value",
        "Dictionary access: fragments_by_site[site] gives you the count for that site",
        "The .join() method combines list items into a string",
        "For a professional report, think about organization: header, sections for each analysis, and a summary at the end."
      ],
      "completionSegment": {
        "narrative": "Your final report compiles everything discovered on this incredible journey. The complete picture emerges:\n\nThe Bridge Builders were a secret society of scholars who foresaw the fall of classical civilization. They preserved not just knowledge, but a METHOD of thinking\u2014computational thinking\u2014encoded in a way that only a future technological civilization could decode.\n\nThey predicted that when humanity redeveloped computing, someone would find their fragments and understand their message: Knowledge transcends time when preserved with wisdom and shared with purpose.\n\n{{ending}}",
        "characterResponse": {
          "success": "\"You've done more than solve a mystery\u2014you've bridged two thousand years of human knowledge. Your analytical skills throughout this journey proved you're a true digital archaeologist. My grandmother would be so proud.\"",
          "struggle": "\"Through every challenge, you persevered. That's what makes a real archaeologist\u2014not perfection, but persistence. You've honored both the ancient scholars and modern science.\""
        }
      }
    }
  ],
  "endings": {
    "seeker": {
      "id": "seeker",
      "title": "The Seeker",
      "requirements": [
        "pursued_mystery",
        "sought_convergence",
        "chose_discovery"
      ],
      "narrative": "At the convergence point, you discover the Bridge Builders still exist\u2014descendants who've waited centuries for someone with your unique skills. They invite you to join them in preserving knowledge for future civilizations. You accept, becoming a bridge between past and future.\n\nDr. Rodriguez smiles. 'My grandmother always said the right person would know what to do. She was right about you.'\n\nYour Python skills and archaeological instincts have uncovered not just ancient history, but a living legacy. You are now part of something greater\u2014a guardian of human knowledge across time.",
      "badge": "seeker_badge",
      "description": "You followed the mystery to its source and joined an ancient tradition"
    },
    "guardian": {
      "id": "guardian",
      "title": "The Guardian",
      "requirements": [
        "chose_preservation",
        "protected_sites",
        "secured_knowledge"
      ],
      "narrative": "Your careful preservation of each site ensures the fragments survive for future generations. The Keepers of Alexandria recognize your wisdom and dedication, naming you the Chief Digital Archivist.\n\nUnder your leadership, a global network forms to protect and study the Bridge Builders' legacy. Museums worldwide showcase your discoveries, but the deepest secrets remain protected, waiting for humanity to be ready.\n\nDr. Rodriguez stays by your side as your partner. Together, you've saved priceless knowledge from being lost or misused.",
      "badge": "guardian_badge",
      "description": "You became the protector of ancient wisdom and founded a new order of digital archaeologists"
    },
    "savior": {
      "id": "savior",
      "title": "The Savior",
      "requirements": [
        "shared_knowledge",
        "chose_enlightenment",
        "helped_humanity"
      ],
      "narrative": "By sharing the Bridge Builders' knowledge freely, you trigger a global renaissance. Their preserved mathematics advances quantum computing by decades. Their astronomical data reveals patterns that revolutionize our understanding of climate cycles, helping prevent future disasters.\n\nThe world remembers you not as the person who found the knowledge, but as the one who gave it away. Schools teach the 'Rodriguez-[YourName] Method' of computational archaeology.\n\nDr. Rodriguez establishes a foundation in both your names, ensuring the Bridge Builders' dream lives on: knowledge belongs to all humanity.",
      "badge": "savior_badge",
      "description": "You gifted ancient wisdom to the world, sparking a new age of enlightenment"
    },
    "scholar": {
      "id": "scholar",
      "title": "The Scholar",
      "requirements": [
        "focused_on_translation",
        "chose_research",
        "valued_understanding"
      ],
      "narrative": "Your meticulous analysis becomes the definitive academic work on the Bridge Builders. Years of careful study reveal layer after layer of meaning in their fragments\u2014mathematical theorems, astronomical observations, even early quantum theory.\n\nYou become the world's leading expert, teaching at Alexandria's rebuilt library. Your students use your Python programs to make new discoveries, continuing your work.\n\nDr. Rodriguez writes in her final letter: 'You chose understanding over glory, wisdom over wealth. The Bridge Builders would recognize you as one of their own\u2014a true scholar.'",
      "badge": "scholar_badge",
      "description": "You devoted your life to understanding and teaching the ancient knowledge"
    }
  },
  "narrativePaths": {
    "secrecyPath": {
      "description": "Following the trail of hidden knowledge",
      "modifiesStages": [
        2,
        3,
        4
      ],
      "unlocks": [
        "secretSocietyRevelation",
        "hiddenDangers"
      ]
    },
    "scientificPath": {
      "description": "Using data analysis to reveal patterns",
      "modifiesStages": [
        2,
        3,
        4
      ],
      "unlocks": [
        "mathematicalCiphers",
        "astronomicalConnections"
      ]
    },
    "transparencyPath": {
      "description": "Sharing discoveries with the global community",
      "modifiesStages": [
        3,
        4,
        5
      ],
      "unlocks": [
        "globalCollaboration",
        "publicSupport"
      ]
    },
    "technologyPath": {
      "description": "Leveraging AI and modern tools",
      "modifiesStages": [
        4,
        5,
        6
      ],
      "unlocks": [
        "aiAssistance",
        "quantumPatterns"
      ]
    },
    "preservationPath": {
      "description": "Racing to protect physical artifacts",
      "modifiesStages": [
        5,
        6,
        7
      ],
      "unlocks": [
        "urgentAction",
        "hiddenArtifacts"
      ]
    },
    "knowledgePath": {
      "description": "Prioritizing understanding over artifacts",
      "modifiesStages": [
        5,
        6,
        7
      ],
      "unlocks": [
        "deeperMeaning",
        "theoreticalBreakthroughs"
      ]
    }
  }
}