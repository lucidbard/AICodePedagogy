{
  "gameInfo": {
    "title": "üèõÔ∏è Digital Archaeology Mystery",
    "subtitle": "Code Your Way Through Ancient Secrets",
    "totalStages": 9
  },
  "stages": [
    {
      "id": 1,
      "title": "The Mysterious Manuscript",
      "story": "Dr. Elena Rodriguez has discovered fragments of an ancient manuscript in the digital archives of the Alexandria Library. The fragments contain references to a lost civilization, but they're scattered and encoded.\n\nYou've been called in as a digital archaeologist to help piece together this mystery using computational analysis.\n\n<strong>üîç Python Concepts: Variables and Print Statements</strong>\n\nIn Python, we store information in <em>variables</em>. Think of variables as labeled boxes that hold data:\n‚Ä¢ Text (strings) must be in quotes: <code>name = \"Alexandria\"</code>\n‚Ä¢ Numbers don't need quotes: <code>count = 23</code>\n‚Ä¢ Use <code>print()</code> to display information\n\nPractice using variables and print statements with the manuscript data provided below.",
      "challenge": "Your task: Complete the code to store the fragment count as a variable, then display both pieces of information using print statements.",
      "data": "Manuscript ID: \"MS-ALEX-2847\"\nFragment Count: 23",
      "starterCode": "# Store the manuscript data as variables and display them\n# We've started with the catalog number - you complete the fragment count\n\ncatalog_number = \"MS-ALEX-2847\"\n# TODO: Create a variable called fragment_count and set it to 23\n\n# Print both variables using print statements\nprint(\"Manuscript Catalog: \" + catalog_number)\n# TODO: Add your print statement for fragment_count here using string concatenation",
      "solution": "catalog_number = \"MS-ALEX-2847\"\nfragment_count = 23\nprint(\"Manuscript Catalog: \" + catalog_number)\nprint(\"Fragments Found: \" + str(fragment_count))",
      "validation": {
        "codePatterns": [
          "fragment_count\\s*=\\s*23",
          "print\\s*\\(.*fragment_count.*\\)"
        ],
        "outputPatterns": [
          "Manuscript Catalog.*MS-ALEX-2847",
          "(Fragments.*23|23.*Fragment)"
        ],
        "description": "Must define fragment_count = 23 and print both variables"
      },
      "hints": [
        "Variables store data. Use = to assign values to variable names.",
        "String variables need quotes: my_text = \"Hello\"",
        "Number variables don't need quotes: my_number = 42",
        "Use print() to display variable contents."
      ]
    },
    {
      "id": 2,
      "title": "Analyzing Fragment Lengths",
      "story": "The manuscript fragments vary greatly in length. Some are mere words, others are complete sentences. Understanding the distribution of fragment sizes might reveal patterns about how the original text was structured.\n\n<strong>üîç Python Concepts: Lists, For Loops, Conditional Statements, and Functions</strong>\n\n<em>Lists</em> store multiple values in a single variable:\n‚Ä¢ Create lists with square brackets: <code>numbers = [1, 2, 3, 4]</code>\n‚Ä¢ <em>For loops</em> let you process each item: <code>for item in my_list:</code>\n‚Ä¢ <code>len()</code> returns how many items are in a list\n\n<em>Conditional statements</em> let your program make decisions:\n‚Ä¢ <code>if</code> checks a condition: <code>if length < 30:</code>\n‚Ä¢ <code>elif</code> checks additional conditions: <code>elif length <= 60:</code>\n‚Ä¢ <code>else</code> handles all other cases: <code>else:</code>\n‚Ä¢ Use comparison operators: <code><</code> (less than), <code><=</code> (less than or equal), <code>></code> (greater than)\n‚Ä¢ Remember to indent code inside if/elif/else blocks!\n\n<em>Functions</em> let you organize and reuse code:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return values with <code>return value1, value2</code>\n‚Ä¢ Call functions to get results: <code>result = my_function(data)</code>\n‚Ä¢ Functions make code more organized and testable\n\n<strong>Example:</strong>\n<code>\ndef categorize_age(age):\n    if age < 18:\n        return \"Child\"\n    elif age <= 65:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n\nresult = categorize_age(25)\nprint(result)  # Prints \"Adult\"\n</code>\n\nPractice combining lists, loops, conditionals, and functions to analyze the fragment data below.",
      "challenge": "Using the provided fragment lengths list, calculate statistics and count fragments by size categories to understand the distribution.",
      "data": "Fragment lengths (characters): [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\nCategories for analysis:\n‚Ä¢ Short fragments:     less than 30 characters\n‚Ä¢ Medium fragments:    30-60 characters  \n‚Ä¢ Long fragments:      more than 60 characters",
      "cells": [
        {
          "title": "Task 1: Count Total Fragments",
          "instruction": "Use the len() function to count how many fragments we have",
          "starterCode": "# Task 1: Count the total number of fragments\nfragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\n# Use len() to count total fragments\n# TODO: Create a variable called total_fragments and set it to the length of fragment_lengths\n# TODO: Print the result using: \"Total fragments found: \" + str(total_fragments)",
          "expectedOutput": [
            "Total fragments found: 10"
          ],
          "validation": {
            "requiredNumbers": [
              10
            ],
            "requiredText": [
              "Total fragments found",
              "10"
            ],
            "outputPatterns": [
              "(Total fragments found.*10|10.*fragments found)",
              "Total fragments.*:.*10"
            ]
          },
          "hints": [
            "len() returns the number of items in a list",
            "Use len(fragment_lengths) to count the fragments",
            "Use str() to convert numbers to strings for concatenation",
            "Remember: \"text\" + str(number) for string concatenation"
          ]
        },
        {
          "title": "Task 2: Calculate Total Characters",
          "instruction": "Use a for loop to add up all the fragment lengths",
          "starterCode": "# Task 2: Calculate total characters using a for loop\n# Note: fragment_lengths is already available from Task 1\n\ntotal_characters = 0\n# TODO: Write a for loop to go through each length in fragment_lengths\n# TODO: In the loop, add each length to total_characters\n# TODO: Print the result using: \"Total characters: \" + str(total_characters)",
          "expectedOutput": [
            "Total characters: 468"
          ],
          "validation": {
            "requiredNumbers": [
              468
            ],
            "requiredText": [
              "Total characters",
              "468"
            ],
            "outputPatterns": [
              "(Total characters.*468|468.*Total characters)",
              "Total characters.*:.*468"
            ]
          },
          "hints": [
            "Use 'for length in fragment_lengths:' to loop through each length",
            "Add each length to total_characters inside the loop",
            "Use: total_characters = total_characters + length",
            "Use str() to convert the number to a string for concatenation"
          ]
        },
        {
          "title": "Task 3: Categorize Fragments",
          "instruction": "Create a function that categorizes fragments by size and returns the counts",
          "starterCode": "# Task 3: Create a function to categorize fragments by size\n# Note: fragment_lengths is still available from previous tasks\n\ndef categorize_fragments(lengths):\n    \"\"\"Categorize fragments by size and return counts.\n    \n    Args:\n        lengths: List of fragment lengths\n        \n    Returns:\n        tuple: (short_count, medium_count, long_count)\n            - short_count: fragments < 30 characters\n            - medium_count: fragments 30-60 characters  \n            - long_count: fragments > 60 characters\n    \"\"\"\n    short_count = 0\n    medium_count = 0\n    long_count = 0\n    \n    # TODO: Write a for loop to go through each length in the lengths parameter\n    # TODO: Use if/elif/else to check the length and increment the right counter\n    # TODO: Return the three counts as a tuple\n    \n    return short_count, medium_count, long_count\n\n# Test your function and display results\nshort, medium, long = categorize_fragments(fragment_lengths)\nprint(f\"Short fragments (< 30 chars): {short}\")\nprint(f\"Medium fragments (30-60 chars): {medium}\")\nprint(f\"Long fragments (> 60 chars): {long}\")",
          "expectedOutput": [
            "Short fragments (< 30 chars): 3",
            "Medium fragments (30-60 chars): 5",
            "Long fragments (> 60 chars): 2"
          ],
          "validation": {
            "requiredNumbers": [
              3,
              5,
              2
            ],
            "requiredText": [
              "Short fragments",
              "Medium fragments",
              "Long fragments"
            ],
            "outputPatterns": [
              "Short fragments.*3",
              "Medium fragments.*5",
              "Long fragments.*2"
            ],
            "codePatterns": [
              "def\\s+categorize_fragments\\s*\\(",
              "return\\s+.*short_count.*medium_count.*long_count",
              "for\\s+\\w+\\s+in\\s+lengths"
            ]
          },
          "hints": [
            "Define a function with def categorize_fragments(lengths):",
            "Use if/elif/else inside the for loop to categorize each length",
            "if length < 30: for short fragments",
            "elif length >= 30 and length <= 60: for medium fragments",
            "else: for long fragments",
            "Return all three counts: return short_count, medium_count, long_count",
            "The function call is already provided - just complete the function body"
          ]
        }
      ],
      "solution": "fragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\n# Task 1: Use len() to count total fragments\ntotal_fragments = len(fragment_lengths)\nprint(\"Total fragments found: \" + str(total_fragments))\n\n# Task 2: Calculate total characters using a for loop\ntotal_characters = 0\nfor length in fragment_lengths:\n    total_characters = total_characters + length\nprint(\"Total characters: \" + str(total_characters))\n\n# Task 3: Create a function to categorize fragments\ndef categorize_fragments(lengths):\n    \"\"\"Categorize fragments by size and return counts.\"\"\"\n    short_count = 0\n    medium_count = 0\n    long_count = 0\n    \n    for length in lengths:\n        if length < 30:\n            short_count += 1\n        elif length >= 30 and length <= 60:\n            medium_count += 1\n        else:\n            long_count += 1\n    \n    return short_count, medium_count, long_count\n\n# Test the function and display results\nshort, medium, long = categorize_fragments(fragment_lengths)\nprint(f\"Short fragments (< 30 chars): {short}\")\nprint(f\"Medium fragments (30-60 chars): {medium}\")\nprint(f\"Long fragments (> 60 chars): {long}\")\n\n# Bonus: Calculate average length\naverage_length = total_characters / total_fragments\nprint(f\"Average fragment length: {round(average_length, 1)} characters\")",
      "hints": [
        "Use len(fragment_lengths) to count how many items are in the list",
        "For loops iterate through each item: for length in fragment_lengths:",
        "Inside the loop, add each length to your total: total_characters = total_characters + length",
        "Functions are defined with def function_name(parameters):",
        "Use if/elif/else inside loops: if length < 30: ... elif length <= 60: ... else:",
        "Functions should return values: return value1, value2, value3",
        "Remember to indent code inside function definitions, loops, and if/elif/else blocks (4 spaces)",
        "Comparison operators: < (less than), <= (less than or equal), > (greater than)"
      ]
    },
    {
      "id": 3,
      "title": "Decoding Fragment Languages",
      "story": "Some fragments appear to be in Latin, others in ancient Greek, and some are too damaged to identify. Understanding the language distribution might help us understand the cultural context.\n\n<strong>üîç Python Concepts: Conditional Statements and Functions</strong>\n\n<em>Conditional statements</em> let your program make decisions:\n‚Ä¢ <code>if</code> checks a condition: <code>if age >= 18:</code>\n‚Ä¢ <code>elif</code> checks additional conditions: <code>elif age >= 13:</code>\n‚Ä¢ <code>==</code> compares values (different from <code>=</code> which assigns)\n‚Ä¢ Remember to indent code inside if/elif blocks!\n\n<em>Functions</em> organize and structure your code:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return multiple values: <code>return value1, value2, value3</code>\n‚Ä¢ Call functions to get results: <code>latin, greek, unknown = count_languages(codes)</code>\n\nPractice using conditionals within functions to analyze language distribution.",
      "challenge": "Create a function that analyzes language codes and returns counts for each language type.",
      "data": "Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]",
      "starterCode": "# Create a function to count language types\n# Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\n# LAT = Latin, GRK = Greek, UNK = Unknown\n\ndef count_languages(language_codes):\n    \"\"\"Count fragments by language type.\n    \n    Args:\n        language_codes: List of language codes (LAT, GRK, UNK)\n        \n    Returns:\n        tuple: (latin_count, greek_count, unknown_count)\n    \"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    # TODO: Write a for loop to go through each code in language_codes\n    # TODO: Use if/elif/else to check the code and increment the right counter\n    # TODO: Return the three counts as a tuple\n    \n    return latin_count, greek_count, unknown_count\n\n# Test your function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(f\"Latin fragments: {latin}\")\nprint(f\"Greek fragments: {greek}\")\nprint(f\"Unknown fragments: {unknown}\")",
      "solution": "def count_languages(language_codes):\n    \"\"\"Count fragments by language type.\"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    for lang in language_codes:\n        if lang == \"LAT\":\n            latin_count += 1\n        elif lang == \"GRK\":\n            greek_count += 1\n        elif lang == \"UNK\":\n            unknown_count += 1\n    \n    return latin_count, greek_count, unknown_count\n\n# Test the function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(f\"Latin fragments: {latin}\")\nprint(f\"Greek fragments: {greek}\")\nprint(f\"Unknown fragments: {unknown}\")",
      "validation": {
        "codePatterns": [
          "def\\s+count_languages\\s*\\(",
          "language_codes",
          "return\\s+.*latin_count.*greek_count.*unknown_count",
          "for\\s+\\w+\\s+in\\s+language_codes",
          "if\\s+.*==.*['\"]LAT['\"]",
          "elif\\s+.*==.*['\"]GRK['\"]"
        ],
        "outputPatterns": [
          "(Latin fragments.*5|5.*Latin)",
          "(Greek fragments.*3|3.*Greek)",
          "(Unknown fragments.*4|4.*Unknown)"
        ],
        "description": "Must create a function that counts language types and returns the counts"
      },
      "hints": [
        "Define the function with def count_languages(language_codes):",
        "Use a for loop inside the function: for lang in language_codes:",
        "Use if/elif/else to categorize: if lang == \"LAT\":",
        "Increment counters: latin_count += 1",
        "Return all three counts: return latin_count, greek_count, unknown_count",
        "The function call is already provided - just complete the function body"
      ]
    },
    {
      "id": 4,
      "title": "Dating the Fragments",
      "story": "Carbon dating and paleographic analysis have provided approximate dates for each fragment. Understanding the temporal distribution might reveal when this civilization flourished.\n\n<strong>üîç Python Concepts: Functions, Min/Max Finding, and Range Analysis</strong>\n\n<em>Functions</em> help organize complex analysis tasks:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return multiple values: <code>return value1, value2</code>\n‚Ä¢ Functions make code reusable and testable\n\n<em>Finding minimum and maximum values:</em>\n‚Ä¢ Start with first item: <code>oldest = dates[0]</code>\n‚Ä¢ Compare in loops: <code>if date < oldest:</code>\n‚Ä¢ Update when finding new extremes: <code>oldest = date</code>\n\n<em>Range checking with conditions:</em>\n‚Ä¢ Combine conditions: <code>if date >= 100 and date < 200:</code>\n‚Ä¢ Use elif for multiple ranges\n‚Ä¢ Count items that meet criteria\n\n<strong>Example:</strong>\n<code>\ndef analyze_scores(scores):\n    highest = scores[0]\n    lowest = scores[0]\n    \n    for score in scores:\n        if score > highest:\n            highest = score\n        if score < lowest:\n            lowest = score\n    \n    return lowest, highest\n\nmin_score, max_score = analyze_scores([85, 92, 78, 96, 88])\nprint(f\"Range: {min_score} to {max_score}\")\n</code>\n\nPractice creating functions to analyze temporal data and calculate date ranges.",
      "challenge": "Create functions to analyze fragment dating data and determine temporal distribution patterns.",
      "data": "Fragment dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]",
      "starterCode": "# Create functions to analyze fragment dating patterns\n# Dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\ndef find_date_range(dates):\n    \"\"\"Find the oldest and newest dates in the collection.\n    \n    Args:\n        dates: List of dates (integers)\n        \n    Returns:\n        tuple: (oldest_date, newest_date)\n    \"\"\"\n    # TODO: Initialize oldest and newest with the first date\n    # TODO: Loop through all dates to find min and max\n    # TODO: Return both values as a tuple\n    \n    return oldest_date, newest_date\n\ndef count_by_century(dates):\n    \"\"\"Count fragments by century periods.\n    \n    Args:\n        dates: List of dates (integers)\n        \n    Returns:\n        tuple: (second_century_count, third_century_count, fourth_century_count)\n    \"\"\"\n    second_century = 0  # 100-199 CE\n    third_century = 0   # 200-299 CE\n    fourth_century = 0  # 300-399 CE\n    \n    # TODO: Loop through dates and categorize by century\n    # TODO: Use if/elif/else to count each century\n    # TODO: Return all three counts\n    \n    return second_century, third_century, fourth_century\n\n# Test your functions\ndates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\n# Analyze date range\noldest, newest = find_date_range(dates)\nprint(f\"Date range: {oldest} CE to {newest} CE\")\nprint(f\"Time span: {newest - oldest} years\")\n\n# Analyze by century\nsecond, third, fourth = count_by_century(dates)\nprint(f\"2nd century (100-199 CE): {second} fragments\")\nprint(f\"3rd century (200-299 CE): {third} fragments\")\nprint(f\"4th century (300-399 CE): {fourth} fragments\")",
      "solution": "def find_date_range(dates):\n    \"\"\"Find the oldest and newest dates in the collection.\"\"\"\n    oldest_date = dates[0]\n    newest_date = dates[0]\n    \n    for date in dates:\n        if date < oldest_date:\n            oldest_date = date\n        if date > newest_date:\n            newest_date = date\n    \n    return oldest_date, newest_date\n\ndef count_by_century(dates):\n    \"\"\"Count fragments by century periods.\"\"\"\n    second_century = 0  # 100-199 CE\n    third_century = 0   # 200-299 CE\n    fourth_century = 0  # 300-399 CE\n    \n    for date in dates:\n        if date >= 100 and date < 200:\n            second_century += 1\n        elif date >= 200 and date < 300:\n            third_century += 1\n        elif date >= 300 and date < 400:\n            fourth_century += 1\n    \n    return second_century, third_century, fourth_century\n\n# Test the functions\ndates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\n# Analyze date range\noldest, newest = find_date_range(dates)\nprint(f\"Date range: {oldest} CE to {newest} CE\")\nprint(f\"Time span: {newest - oldest} years\")\n\n# Analyze by century\nsecond, third, fourth = count_by_century(dates)\nprint(f\"2nd century (100-199 CE): {second} fragments\")\nprint(f\"3rd century (200-299 CE): {third} fragments\")\nprint(f\"4th century (300-399 CE): {fourth} fragments\")",
      "validation": {
        "codePatterns": [
          "def\\s+find_date_range\\s*\\(",
          "def\\s+count_by_century\\s*\\(",
          "return\\s+.*oldest_date.*newest_date",
          "return\\s+.*second_century.*third_century.*fourth_century",
          "for\\s+\\w+\\s+in\\s+dates",
          "if\\s+date\\s+<\\s+oldest_date",
          "if\\s+date\\s+>\\s+newest_date",
          "if\\s+date\\s+>=\\s+100\\s+and\\s+date\\s+<\\s+200"
        ],
        "outputPatterns": [
          "Date range.*150.*380.*CE",
          "Time span.*230.*years",
          "2nd century.*100-199.*2.*fragments",
          "3rd century.*200-299.*4.*fragments",
          "4th century.*300-399.*4.*fragments"
        ],
        "description": "Must create functions for date range analysis and century counting"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Start min/max with first item: oldest_date = dates[0]",
        "Compare in loops: if date < oldest_date: oldest_date = date",
        "For century ranges: if date >= 100 and date < 200:",
        "Return multiple values: return value1, value2, value3",
        "The function calls are provided - complete the function bodies"
      ]
    },
    {
      "id": 5,
      "title": "Word Frequency Analysis",
      "story": "You've transcribed some key words from the legible fragments. Analyzing word frequency might reveal important themes or repeated concepts in this ancient text.\n\n<strong>üîç Python Concepts: Dictionary-like Counting and Functions</strong>\n\n<em>Functions</em> help organize data analysis tasks:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return structured data: <code>return counts_dict</code>\n‚Ä¢ Functions make analysis reusable and clear\n\n<em>Counting with variables (simulating dictionary behavior):</em>\n‚Ä¢ Use separate variables for each category\n‚Ä¢ Compare strings with <code>==</code>: <code>if word == \"temple\":</code>\n‚Ä¢ Increment counters: <code>temple_count += 1</code>\n‚Ä¢ Track maximum values for analysis\n\n<em>Finding the maximum frequency:</em>\n‚Ä¢ Start with first category as highest\n‚Ä¢ Compare each count: <code>if gold_count > highest_count:</code>\n‚Ä¢ Update both the word and count when finding new maximum\n\n<strong>Example:</strong>\n<code>\ndef count_colors(colors):\n    red_count = 0\n    blue_count = 0\n    green_count = 0\n    \n    for color in colors:\n        if color == \"red\":\n            red_count += 1\n        elif color == \"blue\":\n            blue_count += 1\n        elif color == \"green\":\n            green_count += 1\n    \n    return red_count, blue_count, green_count\n\nred, blue, green = count_colors([\"red\", \"blue\", \"red\", \"green\"])\nprint(f\"Red: {red}, Blue: {blue}, Green: {green}\")\n</code>\n\nPractice creating functions to analyze word frequency patterns in ancient texts.",
      "challenge": "Create a function to analyze word frequencies and identify the most common themes in the fragments.",
      "data": "Words found: [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]",
      "starterCode": "# Create a function to analyze word frequency patterns\n# Words: [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\ndef analyze_word_frequency(words):\n    \"\"\"Count frequency of key words in the fragments.\n    \n    Args:\n        words: List of words found in fragments\n        \n    Returns:\n        tuple: (temple_count, gold_count, sacred_count, ritual_count)\n    \"\"\"\n    temple_count = 0\n    gold_count = 0\n    sacred_count = 0\n    ritual_count = 0\n    \n    # TODO: Loop through words and count each type\n    # TODO: Use if/elif statements to categorize words\n    # TODO: Return all four counts as a tuple\n    \n    return temple_count, gold_count, sacred_count, ritual_count\n\ndef find_most_common_word(temple_count, gold_count, sacred_count, ritual_count):\n    \"\"\"Find the word with the highest frequency.\n    \n    Args:\n        temple_count, gold_count, sacred_count, ritual_count: Word frequencies\n        \n    Returns:\n        tuple: (most_common_word, highest_count)\n    \"\"\"\n    # TODO: Start with temple as the most common\n    # TODO: Compare each count and update if higher\n    # TODO: Return the word and its count\n    \n    return most_common_word, highest_count\n\n# Test your functions\nwords = [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\n# Analyze frequencies\ntemple, gold, sacred, ritual = analyze_word_frequency(words)\nprint(\"Word frequencies:\")\nprint(f\"temple: {temple}\")\nprint(f\"gold: {gold}\")\nprint(f\"sacred: {sacred}\")\nprint(f\"ritual: {ritual}\")\n\n# Find most common\nmost_common, highest = find_most_common_word(temple, gold, sacred, ritual)\nprint(f\"\\nMost common word: {most_common} (appears {highest} times)\")",
      "solution": "def analyze_word_frequency(words):\n    \"\"\"Count frequency of key words in the fragments.\"\"\"\n    temple_count = 0\n    gold_count = 0\n    sacred_count = 0\n    ritual_count = 0\n    \n    for word in words:\n        if word == \"temple\":\n            temple_count += 1\n        elif word == \"gold\":\n            gold_count += 1\n        elif word == \"sacred\":\n            sacred_count += 1\n        elif word == \"ritual\":\n            ritual_count += 1\n    \n    return temple_count, gold_count, sacred_count, ritual_count\n\ndef find_most_common_word(temple_count, gold_count, sacred_count, ritual_count):\n    \"\"\"Find the word with the highest frequency.\"\"\"\n    most_common_word = \"temple\"\n    highest_count = temple_count\n    \n    if gold_count > highest_count:\n        most_common_word = \"gold\"\n        highest_count = gold_count\n    if sacred_count > highest_count:\n        most_common_word = \"sacred\"\n        highest_count = sacred_count\n    if ritual_count > highest_count:\n        most_common_word = \"ritual\"\n        highest_count = ritual_count\n    \n    return most_common_word, highest_count\n\n# Test the functions\nwords = [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]\n\n# Analyze frequencies\ntemple, gold, sacred, ritual = analyze_word_frequency(words)\nprint(\"Word frequencies:\")\nprint(f\"temple: {temple}\")\nprint(f\"gold: {gold}\")\nprint(f\"sacred: {sacred}\")\nprint(f\"ritual: {ritual}\")\n\n# Find most common\nmost_common, highest = find_most_common_word(temple, gold, sacred, ritual)\nprint(f\"\\nMost common word: {most_common} (appears {highest} times)\")",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_word_frequency\\s*\\(",
          "def\\s+find_most_common_word\\s*\\(",
          "return\\s+.*temple_count.*gold_count.*sacred_count.*ritual_count",
          "return\\s+.*most_common_word.*highest_count",
          "for\\s+\\w+\\s+in\\s+words",
          "if\\s+word\\s+==\\s+['\"]temple['\"]",
          "if\\s+.*_count\\s+>\\s+highest_count"
        ],
        "outputPatterns": [
          "Word frequencies",
          "temple.*4",
          "gold.*3",
          "sacred.*3",
          "ritual.*2",
          "Most common word.*temple.*4"
        ],
        "description": "Must create functions for word frequency analysis and finding maximum"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use if/elif to categorize words: if word == \"temple\":",
        "Increment counters: temple_count += 1",
        "For finding max, start with first as highest",
        "Compare each count: if gold_count > highest_count:",
        "Update both word and count when finding new maximum",
        "Return multiple values: return value1, value2, value3, value4"
      ]
    },
    {
      "id": 6,
      "title": "Fragment Reconstruction",
      "story": "Some fragments appear to be parts of the same document. By analyzing character patterns and common sequences, you can identify which fragments belong together.\n\n<strong>üîç Python Concepts: String Methods and Boolean Logic</strong>\n\nWorking with text strings:\n‚Ä¢ <code>.startswith()</code> checks how a string begins: <code>text.startswith(\"The\")</code>\n‚Ä¢ <code>.endswith()</code> checks how a string ends: <code>text.endswith(\"end\")</code>\n‚Ä¢ <code>in</code> checks if text contains something: <code>\"temple\" in text</code>\n‚Ä¢ <code>and</code> combines conditions: <code>if condition1 and condition2:</code>\n\nPractice using string methods to match and categorize fragment patterns.",
      "challenge": "Analyze fragments to find matching patterns and group related pieces together.",
      "data": "Fragment texts: [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]",
      "starterCode": "# Match fragments that share common words or patterns\n# Fragments: [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]\n\n# Your code here:\n",
      "solution": "fragments = [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]\n\n# Count fragments containing key words\ntemple_fragments = 0\ntimes_fragments = 0\naltar_fragments = 0\n\nfor fragment in fragments:\n    if \"temple\" in fragment:\n        temple_fragments = temple_fragments + 1\n        print(\"Temple fragment:\", fragment)\n    elif \"times\" in fragment:\n        times_fragments = times_fragments + 1\n        print(\"Times fragment:\", fragment)\n    elif \"altar\" in fragment:\n        altar_fragments = altar_fragments + 1\n        print(\"Altar fragment:\", fragment)\n\nprint(\"\\nFragment groups:\")\nprint(\"Temple group:\", temple_fragments, \"fragments\")\nprint(\"Times group:\", times_fragments, \"fragments\")\nprint(\"Altar group:\", altar_fragments, \"fragments\")\n\n# Find fragments that might connect (ending word matches starting word)\nfor i in range(len(fragments)):\n    for j in range(len(fragments)):\n        if i != j:  # Don't compare fragment to itself\n            frag1 = fragments[i]\n            frag2 = fragments[j]\n            # Simple connection check - if fragment 1 ends with a word that fragment 2 starts with\n            if frag1.split()[-1] in frag2:\n                print(f\"Possible connection: '{frag1}' -> '{frag2}'\")",
      "validation": {
        "codePatterns": [
          "fragments\\s*=\\s*\\[.*\\]",
          "for\\s+\\w+\\s+in\\s+fragments",
          "if\\s+['\"]temple['\"]\\s+in\\s+\\w+",
          "(temple_fragments|times_fragments|altar_fragments)",
          "range\\(len\\(fragments\\)\\)"
        ],
        "outputPatterns": [
          "Temple fragment.*The sacred temple",
          "Temple fragment.*temple was built",
          "Times fragment.*In ancient times",
          "Times fragment.*times were different",
          "Altar fragment.*The golden altar",
          "Altar fragment.*altar stood tall"
        ],
        "description": "Must group fragments by common words and find connections"
      },
      "hints": [
        "Use 'in' to check if a word appears in a fragment: if \"temple\" in fragment:",
        "Use .split() to break text into words: fragment.split()",
        "fragment.split()[-1] gets the last word of a fragment",
        "Compare fragments in nested loops to find connections",
        "Use != to check if indices are different: if i != j:"
      ]
    },
    {
      "id": 7,
      "title": "Geographic Distribution",
      "story": "The fragments were found at different archaeological sites. Understanding their geographic distribution might reveal trade routes or cultural connections.\n\n<strong>üîç Python Concepts: Functions, Parallel Lists, and Statistical Analysis</strong>\n\n<em>Functions</em> organize complex data analysis:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Process multiple related lists together\n‚Ä¢ Return organized results: <code>return statistics_dict</code>\n‚Ä¢ Functions make statistical analysis clear and reusable\n\n<em>Working with parallel lists:</em>\n‚Ä¢ Use same index for related data: <code>sites[i]</code> and <code>counts[i]</code>\n‚Ä¢ <code>range(len(list))</code> creates indices: <code>for i in range(len(sites)):</code>\n‚Ä¢ Access corresponding elements together\n\n<em>Statistical calculations:</em>\n‚Ä¢ Total: <code>sum(counts)</code> or manual addition\n‚Ä¢ Percentages: <code>(count / total) * 100</code>\n‚Ä¢ Use <code>round()</code> for clean formatting: <code>round(percentage, 1)</code>\n‚Ä¢ Find maximum with comparisons\n\n<strong>Example:</strong>\n<code>\ndef analyze_sales(stores, sales):\n    total_sales = sum(sales)\n    max_sales = 0\n    top_store = \"\"\n    \n    for i in range(len(stores)):\n        if sales[i] > max_sales:\n            max_sales = sales[i]\n            top_store = stores[i]\n    \n    return total_sales, top_store, max_sales\n\ntotal, store, amount = analyze_sales([\"A\", \"B\", \"C\"], [100, 150, 120])\nprint(f\"Total: {total}, Top: {store} with {amount}\")\n</code>\n\nPractice creating functions to analyze geographic distribution with statistical calculations.",
      "challenge": "Create functions to analyze geographic distribution and calculate site statistics.",
      "data": "Sites: [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\nFragment counts: [15, 8, 12, 5]",
      "starterCode": "# Create functions to analyze geographic distribution of fragments\n# Sites: [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\n# Counts: [15, 8, 12, 5]\n\ndef calculate_site_statistics(sites, counts):\n    \"\"\"Calculate total fragments and site percentages.\n    \n    Args:\n        sites: List of site names\n        counts: List of fragment counts for each site\n        \n    Returns:\n        tuple: (total_fragments, site_percentages)\n        where site_percentages is a list of (site, count, percentage) tuples\n    \"\"\"\n    # TODO: Calculate total fragments\n    # TODO: Create list of site statistics with percentages\n    # TODO: Return total and statistics list\n    \n    return total_fragments, site_statistics\n\ndef find_major_sites(sites, counts, threshold=10):\n    \"\"\"Find sites with fragment counts above threshold.\n    \n    Args:\n        sites: List of site names\n        counts: List of fragment counts\n        threshold: Minimum fragments to be considered major\n        \n    Returns:\n        tuple: (top_site, top_count, major_sites_list)\n    \"\"\"\n    # TODO: Find site with most fragments\n    # TODO: Create list of major sites (>= threshold)\n    # TODO: Return top site info and major sites list\n    \n    return top_site, top_count, major_sites\n\n# Test your functions\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\ncounts = [15, 8, 12, 5]\n\n# Calculate statistics\ntotal, statistics = calculate_site_statistics(sites, counts)\nprint(\"Geographic Distribution of Fragments:\")\nprint(f\"Total fragments: {total}\")\nprint()\n\nfor site, count, percentage in statistics:\n    print(f\"{site}: {count} fragments ({percentage}%)\")\n\n# Find major sites\ntop_site, top_count, major_sites = find_major_sites(sites, counts)\nprint(f\"\\nMost fragments found at: {top_site} ({top_count} fragments)\")\nprint(f\"Major sites (‚â•10 fragments): {len(major_sites)} sites\")\nfor site in major_sites:\n    print(f\"- {site}\")",
      "solution": "def calculate_site_statistics(sites, counts):\n    \"\"\"Calculate total fragments and site percentages.\"\"\"\n    total_fragments = sum(counts)\n    site_statistics = []\n    \n    for i in range(len(sites)):\n        site = sites[i]\n        count = counts[i]\n        percentage = round((count / total_fragments) * 100, 1)\n        site_statistics.append((site, count, percentage))\n    \n    return total_fragments, site_statistics\n\ndef find_major_sites(sites, counts, threshold=10):\n    \"\"\"Find sites with fragment counts above threshold.\"\"\"\n    # Find top site\n    top_site = sites[0]\n    top_count = counts[0]\n    \n    for i in range(len(sites)):\n        if counts[i] > top_count:\n            top_count = counts[i]\n            top_site = sites[i]\n    \n    # Find major sites\n    major_sites = []\n    for i in range(len(sites)):\n        if counts[i] >= threshold:\n            major_sites.append(sites[i])\n    \n    return top_site, top_count, major_sites\n\n# Test the functions\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\ncounts = [15, 8, 12, 5]\n\n# Calculate statistics\ntotal, statistics = calculate_site_statistics(sites, counts)\nprint(\"Geographic Distribution of Fragments:\")\nprint(f\"Total fragments: {total}\")\nprint()\n\nfor site, count, percentage in statistics:\n    print(f\"{site}: {count} fragments ({percentage}%)\")\n\n# Find major sites\ntop_site, top_count, major_sites = find_major_sites(sites, counts)\nprint(f\"\\nMost fragments found at: {top_site} ({top_count} fragments)\")\nprint(f\"Major sites (‚â•10 fragments): {len(major_sites)} sites\")\nfor site in major_sites:\n    print(f\"- {site}\")",
      "validation": {
        "codePatterns": [
          "def\\s+calculate_site_statistics\\s*\\(",
          "def\\s+find_major_sites\\s*\\(",
          "return\\s+.*total_fragments.*site_statistics",
          "return\\s+.*top_site.*top_count.*major_sites",
          "sum\\(counts\\)",
          "range\\(len\\(sites\\)\\)",
          "sites\\[i\\]",
          "counts\\[i\\]",
          "round\\(.*\\*\\s*100.*\\)"
        ],
        "outputPatterns": [
          "Total fragments.*40",
          "Alexandria.*15.*37\\.5",
          "Memphis.*8.*20\\.0",
          "Thebes.*12.*30\\.0",
          "Aswan.*5.*12\\.5",
          "Most fragments found at.*Alexandria.*15",
          "Major sites.*‚â•10.*2.*sites",
          "- Alexandria",
          "- Thebes"
        ],
        "description": "Must create functions for geographic analysis with parallel lists and statistics"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use sum(counts) to calculate total",
        "Use range(len(sites)) to loop through indices",
        "Access parallel data: sites[i] and counts[i]",
        "Calculate percentage: (count / total) * 100",
        "Use round(percentage, 1) for formatting",
        "Find max by comparing: if counts[i] > top_count:",
        "Create lists with .append(): major_sites.append(site)"
      ]
    },
    {
      "id": 8,
      "title": "Digital Restoration",
      "story": "Using digital imaging techniques, you've recovered some damaged text. The restoration process involves analyzing character patterns and filling in gaps based on context.\n\n<strong>üîç Python Concepts: Functions and String Processing</strong>\n\n<em>Functions</em> organize text processing workflows:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Process text systematically\n‚Ä¢ Return processed results and statistics\n‚Ä¢ Functions make text analysis modular and testable\n\n<em>String manipulation methods:</em>\n‚Ä¢ <code>.replace()</code> substitutes text: <code>text.replace(\"?\", \"a\")</code>\n‚Ä¢ <code>.count()</code> counts occurrences: <code>text.count(\"?\")</code>\n‚Ä¢ <code>.capitalize()</code> formats text: <code>text.capitalize()</code>\n‚Ä¢ <code>len()</code> measures length: <code>len(text)</code>\n‚Ä¢ Chain operations for complex processing\n\n<em>Text restoration workflow:</em>\n‚Ä¢ Analyze damage patterns\n‚Ä¢ Apply systematic replacements\n‚Ä¢ Calculate restoration statistics\n‚Ä¢ Format final output\n\n<strong>Example:</strong>\n<code>\ndef clean_text(messy_text):\n    # Remove unwanted characters\n    step1 = messy_text.replace(\"*\", \"\")\n    step2 = step1.replace(\"#\", \"\")\n    \n    # Format properly\n    clean = step2.capitalize()\n    \n    return clean, len(messy_text), len(clean)\n\nresult, original_len, clean_len = clean_text(\"h*ell#o w*orld\")\nprint(f\"'{result}' (reduced from {original_len} to {clean_len} chars)\")\n</code>\n\nPractice creating functions to restore and analyze damaged ancient texts.",
      "challenge": "Create functions to systematically restore damaged text and calculate restoration statistics.",
      "data": "Damaged text: \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"",
      "starterCode": "# Create functions to restore damaged text and analyze results\n# Damaged: \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n# Pattern: ? represents missing vowels\n\ndef analyze_damage(text):\n    \"\"\"Analyze the extent of damage in the text.\n    \n    Args:\n        text: The damaged text string\n        \n    Returns:\n        tuple: (total_chars, damaged_chars, damage_percentage)\n    \"\"\"\n    # TODO: Count total characters and damaged characters (?)\n    # TODO: Calculate damage percentage\n    # TODO: Return statistics\n    \n    return total_chars, damaged_chars, damage_percentage\n\ndef restore_text(damaged_text):\n    \"\"\"Restore damaged text using pattern matching.\n    \n    Args:\n        damaged_text: Text with ? representing missing characters\n        \n    Returns:\n        tuple: (restored_text, restoration_steps)\n        where restoration_steps is the number of replacements made\n    \"\"\"\n    # TODO: Apply systematic replacements for common words\n    # TODO: Count how many replacements were made\n    # TODO: Capitalize the final result\n    # TODO: Return restored text and step count\n    \n    return final_text, total_steps\n\n# Test your functions\ndamaged = \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n\nprint(\"=== DIGITAL RESTORATION ANALYSIS ===\")\nprint(f\"Original damaged text: {damaged}\")\nprint()\n\n# Analyze damage\ntotal, damaged_count, percentage = analyze_damage(damaged)\nprint(f\"Damage analysis:\")\nprint(f\"- Total characters: {total}\")\nprint(f\"- Damaged characters: {damaged_count}\")\nprint(f\"- Damage level: {percentage}%\")\nprint()\n\n# Restore text\nrestored, steps = restore_text(damaged)\nprint(f\"Restoration complete in {steps} steps\")\nprint(f\"Final restored text: {restored}\")\nprint()\n\n# Compare results\nprint(f\"Text length: {len(damaged)} ‚Üí {len(restored)} characters\")\nprint(f\"Characters restored: {damaged_count}\")",
      "solution": "def analyze_damage(text):\n    \"\"\"Analyze the extent of damage in the text.\"\"\"\n    total_chars = len(text)\n    damaged_chars = text.count(\"?\")\n    damage_percentage = round((damaged_chars / total_chars) * 100, 1)\n    \n    return total_chars, damaged_chars, damage_percentage\n\ndef restore_text(damaged_text):\n    \"\"\"Restore damaged text using pattern matching.\"\"\"\n    original_damaged = damaged_text.count(\"?\")\n    \n    # Apply systematic replacements\n    step1 = damaged_text.replace(\"th?\", \"the\")\n    step2 = step1.replace(\"s?cr?d\", \"sacred\")\n    step3 = step2.replace(\"t?mpl?\", \"temple\")\n    step4 = step3.replace(\"w?s\", \"was\")\n    step5 = step4.replace(\"b??lt\", \"built\")\n    step6 = step5.replace(\"?n\", \"in\")\n    step7 = step6.replace(\"?nc??nt\", \"ancient\")\n    step8 = step7.replace(\"t?m?s\", \"times\")\n    \n    # Final formatting\n    final_text = step8.capitalize()\n    \n    # Count total replacement operations\n    total_steps = 8\n    \n    return final_text, total_steps\n\n# Test the functions\ndamaged = \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"\n\nprint(\"=== DIGITAL RESTORATION ANALYSIS ===\")\nprint(f\"Original damaged text: {damaged}\")\nprint()\n\n# Analyze damage\ntotal, damaged_count, percentage = analyze_damage(damaged)\nprint(f\"Damage analysis:\")\nprint(f\"- Total characters: {total}\")\nprint(f\"- Damaged characters: {damaged_count}\")\nprint(f\"- Damage level: {percentage}%\")\nprint()\n\n# Restore text\nrestored, steps = restore_text(damaged)\nprint(f\"Restoration complete in {steps} steps\")\nprint(f\"Final restored text: {restored}\")\nprint()\n\n# Compare results\nprint(f\"Text length: {len(damaged)} ‚Üí {len(restored)} characters\")\nprint(f\"Characters restored: {damaged_count}\")",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_damage\\s*\\(",
          "def\\s+restore_text\\s*\\(",
          "return\\s+.*total_chars.*damaged_chars.*damage_percentage",
          "return\\s+.*final_text.*total_steps",
          "\\.count\\(['\"]\\?['\"]\\)",
          "len\\(.*\\)",
          "\\.replace\\(",
          "\\.capitalize\\(\\)",
          "round\\(.*\\*\\s*100.*\\)"
        ],
        "outputPatterns": [
          "=== DIGITAL RESTORATION ANALYSIS ===",
          "Original damaged text.*th\\?.*t\\?m\\?s",
          "Total characters.*42",
          "Damaged characters.*13",
          "Damage level.*30\\.9",
          "Restoration complete.*8.*steps",
          "Final restored text.*The sacred temple was built in ancient times",
          "Text length.*42.*‚Üí.*46",
          "Characters restored.*13"
        ],
        "description": "Must create functions for text restoration with damage analysis and systematic replacement"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use .count(\"?\") to count damaged characters",
        "Use len(text) to get total character count",
        "Calculate percentage: (damaged / total) * 100",
        "Chain replacements: step1 = text.replace(...), step2 = step1.replace(...)",
        "Use .capitalize() for final formatting",
        "Return multiple values: return value1, value2, value3",
        "Track the number of replacement operations performed"
      ]
    },
    {
      "id": 9,
      "title": "The Final Revelation",
      "story": "All your analysis has led to this moment. By combining the data from all previous stages, you can now piece together the complete story of this ancient civilization.\n\n<strong>üîç Python Concepts: Bringing It All Together</strong>\n\nSynthesizing your skills:\n‚Ä¢ Use all the concepts you've learned: variables, lists, loops, conditionals\n‚Ä¢ Combine data from multiple sources\n‚Ä¢ Create comprehensive analysis reports\n‚Ä¢ Present findings in a clear, organized format\n\nThis final challenge tests your mastery of all Python fundamentals covered in this adventure.",
      "challenge": "Create a comprehensive analysis report combining insights from all your previous investigations.",
      "data": "Final data synthesis using all previous findings:\n‚Ä¢ Fragment analysis\n‚Ä¢ Language distribution\n‚Ä¢ Dating results\n‚Ä¢ Word frequencies\n‚Ä¢ Geographic distribution",
      "starterCode": "# Create a comprehensive report of your digital archaeology findings\n# Combine insights from all previous stages\n\nprint(\"üèõÔ∏è DIGITAL ARCHAEOLOGY FINAL REPORT\")\nprint(\"====================================\")\nprint()\n\n# Your comprehensive analysis here:\n",
      "solution": "print(\"üèõÔ∏è DIGITAL ARCHAEOLOGY FINAL REPORT\")\nprint(\"====================================\")\nprint()\n\n# Summary data from all investigations\ntotal_fragments = 40  # Combined from all stages\nlanguages = [\"Latin\", \"Greek\", \"Unknown\"]\nlanguage_counts = [18, 15, 7]\ndate_range = [150, 380]  # Earliest to latest dates\nkey_words = [\"temple\", \"sacred\", \"gold\", \"ritual\"]\nword_frequencies = [12, 8, 7, 5]\nsites = [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\nsite_counts = [15, 8, 12, 5]\n\nprint(\"üìä FRAGMENT ANALYSIS SUMMARY\")\nprint(f\"Total fragments discovered: {total_fragments}\")\nprint(f\"Date range: {date_range[0]} - {date_range[1]} CE\")\nprint(f\"Time span: {date_range[1] - date_range[0]} years\")\nprint()\n\nprint(\"üó£Ô∏è LANGUAGE DISTRIBUTION\")\nfor i in range(len(languages)):\n    language = languages[i]\n    count = language_counts[i]\n    percentage = (count / sum(language_counts)) * 100\n    print(f\"{language}: {count} fragments ({round(percentage, 1)}%)\")\nprint()\n\nprint(\"üìç GEOGRAPHIC DISTRIBUTION\")\nfor i in range(len(sites)):\n    site = sites[i]\n    count = site_counts[i]\n    percentage = (count / sum(site_counts)) * 100\n    print(f\"{site}: {count} fragments ({round(percentage, 1)}%)\")\nprint()\n\nprint(\"üîë KEY THEMES (Most Frequent Words)\")\nfor i in range(len(key_words)):\n    word = key_words[i]\n    freq = word_frequencies[i]\n    print(f\"{word}: {freq} occurrences\")\nprint()\n\nprint(\"üè∫ HISTORICAL CONCLUSIONS\")\nprint(\"Based on the digital archaeology analysis:\")\nprint(\"‚Ä¢ This civilization flourished from 150-380 CE\")\nprint(\"‚Ä¢ Bilingual culture (Latin & Greek influences)\")\nprint(\"‚Ä¢ Religious focus evident from word frequencies\")\nprint(\"‚Ä¢ Alexandria was the major cultural center\")\nprint(\"‚Ä¢ Trading connections across multiple Egyptian sites\")\nprint()\n\nprint(\"üéØ MISSION ACCOMPLISHED!\")\nprint(\"You have successfully decoded the ancient mystery!\")\nprint(\"The digital archaeology investigation is complete.\")\n\n# Calculate and display overall statistics\nmost_common_word = key_words[0]\nlargest_site = sites[0]\nmax_site_count = site_counts[0]\nfor i in range(len(sites)):\n    if site_counts[i] > max_site_count:\n        max_site_count = site_counts[i]\n        largest_site = sites[i]\n\nprint()\nprint(\"üìà KEY STATISTICS\")\nprint(f\"Most significant site: {largest_site} ({max_site_count} fragments)\")\nprint(f\"Most common theme: {most_common_word} ({word_frequencies[0]} mentions)\")\nprint(f\"Primary languages: {languages[0]} and {languages[1]}\")\nprint(f\"Research period: {date_range[1] - date_range[0]} years of civilization\")",
      "validation": {
        "codePatterns": [
          "total_fragments\\s*=\\s*40",
          "languages\\s*=\\s*\\[.*Latin.*Greek.*Unknown.*\\]",
          "language_counts\\s*=\\s*\\[.*18.*15.*7.*\\]",
          "date_range\\s*=\\s*\\[.*150.*380.*\\]",
          "for\\s+i\\s+in\\s+range\\(",
          "percentage\\s*=.*sum\\(",
          "round\\(",
          "print\\(f.*\\{.*\\}.*\\)"
        ],
        "outputPatterns": [
          "üèõÔ∏è DIGITAL ARCHAEOLOGY FINAL REPORT",
          "Total fragments discovered.*40",
          "Date range.*150.*380.*CE",
          "Time span.*230.*years",
          "Latin.*18.*45\\.0",
          "Greek.*15.*37\\.5",
          "Unknown.*7.*17\\.5",
          "Alexandria.*15.*37\\.5",
          "temple.*12.*occurrences",
          "MISSION ACCOMPLISHED",
          "Most significant site.*Alexandria.*15",
          "Most common theme.*temple.*12",
          "Primary languages.*Latin.*Greek",
          "Research period.*230.*years"
        ],
        "description": "Must create comprehensive report using all programming concepts learned"
      },
      "hints": [
        "Combine data from all previous stages",
        "Use lists to organize related information",
        "Calculate percentages: (count / total) * 100",
        "Use loops to process multiple pieces of data",
        "Present findings in a clear, organized report format",
        "Use string formatting to create professional output"
      ]
    }
  ]
}