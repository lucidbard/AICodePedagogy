{
  "gameInfo": {
    "title": "üèõÔ∏è Digging into AI",
    "subtitle": "An Archaelogical Python Adventure",
    "totalStages": 9,
    "hasNarrativeBranching": true
  },
  "characterInfo": {
    "name": "Dr. Elena Rodriguez",
    "title": "Lead Digital Archaeologist",
    "personality": "Brilliant, passionate about archaeology, supportive mentor",
    "backstory": "Has been investigating these fragments for 5 years after discovering them in a forgotten server in the Alexandria Library's digital archives"
  },
  "stages": [
    {
      "id": 1,
      "title": "The Mysterious Manuscript",
      "story": "Dr. Elena Rodriguez has discovered fragments of an ancient manuscript in the digital archives of the Alexandria Library. The fragments contain references to a lost civilization, but they're scattered and encoded.\n\nYou've been called in as a digital archaeologist to help piece together this mystery using computational analysis.\n\n<strong>üîç Python Concepts: Variables and Print Statements</strong>\n\nIn Python, we store information in <em>variables</em>. Think of variables as labeled boxes that hold data:\n‚Ä¢ Text (strings) must be in quotes: <code>name = \"Alexandria\"</code>\n‚Ä¢ Numbers don't need quotes: <code>count = 23</code>\n‚Ä¢ Use <code>print()</code> to display information\n\nPractice using variables and print statements with the manuscript data provided below.",
      "challenge": "Your task: Complete the code to store the fragment count as a variable, then display both pieces of information using print statements.",
      "data": "Manuscript ID: \"MS-ALEX-2847\"\nFragment Count: 23",
      "starterCode": "# Store the manuscript data as variables and display them\n# We've started with the catalog number - you complete the fragment count\n\ncatalog_number = \"MS-ALEX-2847\"\n# TODO: Create a variable called fragment_count and set it to 23\n\n# Print both variables using print statements\nprint(\"Manuscript Catalog: \" + catalog_number)\n# TODO: Add your print statement for fragment_count here using string concatenation",
      "solution": "catalog_number = \"MS-ALEX-2847\"\nfragment_count = 23\nprint(\"Manuscript Catalog: \" + catalog_number)\nprint(\"Fragments Found: \" + str(fragment_count))",
      "validation": {
        "codePatterns": [
          "fragment_count\\s*=\\s*23",
          "print\\s*\\(.*fragment_count.*\\)"
        ],
        "outputPatterns": [
          "Manuscript Catalog.*MS-ALEX-2847",
          "(Fragments.*23|23.*Fragment)"
        ],
        "description": "Must define fragment_count = 23 and print both variables"
      },
      "hints": [
        "Variables store data. Use = to assign values to variable names.",
        "String variables need quotes: my_text = \"Hello\"",
        "Number variables don't need quotes: my_number = 42",
        "Use print() to display variable contents."
      ],
      "completionSegment": {
        "narrative": "As the fragment count appears on screen, the terminal suddenly flickers. A video call window opens‚Äîit's Dr. Rodriguez, and she looks both excited and concerned.\n\n\"{{playerName}}, excellent work cataloging that initial data! But I need to tell you something... These aren't just random fragments. Look at this‚Äî\" She shares her screen, showing a pattern analysis. \"23 fragments, all deliberately separated. Someone wanted to hide something important.\"\n\nShe pauses, studying the data you've just processed. \"The manuscript ID you logged... MS-ALEX-2847... that's from the restricted archive section. How did these fragments end up there?\"",
        "characterResponse": {
          "success": "\"Your code was clean and efficient. {{playerAction}}‚Äîthat's exactly the systematic approach we need for this investigation.\"",
          "struggle": "\"I see you worked through {{struggledConcept}}. Don't worry, even experienced archaeologists struggle with new tools. What matters is you got the data we needed.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez leans closer to the camera. \"We have two immediate leads to follow. What's your archaeological instinct telling you?\"",
          "options": [
            {
              "id": "investigate_restriction",
              "text": "Investigate why these fragments were in the restricted section",
              "consequence": "secrecyPath",
              "preview": "Focus on the conspiracy angle‚Äîwho hid these and why?"
            },
            {
              "id": "analyze_separation",
              "text": "Analyze the pattern of how the fragments were separated",
              "consequence": "scientificPath",
              "preview": "Use data science to understand the fragmentation method"
            }
          ]
        }
      }
    },
    {
      "id": 2,
      "title": "Analyzing Fragment Lengths",
      "story": "The manuscript fragments vary greatly in length. Some are mere words, others are complete sentences. Understanding the distribution of fragment sizes might reveal patterns about how the original text was structured.\n\n<strong>üîç Python Concepts: Lists, For Loops, Conditional Statements, and Functions</strong>\n\n<em>Lists</em> store multiple values in a single variable:\n‚Ä¢ Create lists with square brackets: <code>numbers = [1, 2, 3, 4]</code>\n‚Ä¢ <em>For loops</em> let you process each item: <code>for item in my_list:</code>\n‚Ä¢ <code>len()</code> returns how many items are in a list\n\n<em>Conditional statements</em> let your program make decisions:\n‚Ä¢ <code>if</code> checks a condition: <code>if length < 30:</code>\n‚Ä¢ <code>elif</code> checks additional conditions: <code>elif length <= 60:</code>\n‚Ä¢ <code>else</code> handles all other cases: <code>else:</code>\n‚Ä¢ Use comparison operators: <code><</code> (less than), <code><=</code> (less than or equal), <code>></code> (greater than)\n‚Ä¢ Remember to indent code inside if/elif/else blocks!\n\n<em>Functions</em> let you organize and reuse code:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return values with <code>return value1, value2</code>\n‚Ä¢ Call functions to get results: <code>result = my_function(data)</code>\n‚Ä¢ Functions make code more organized and testable\n\n<strong>Example:</strong>\n<code>\ndef categorize_age(age):\n    if age < 18:\n        return \"Child\"\n    elif age <= 65:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n\nresult = categorize_age(25)\nprint(result)  # Prints \"Adult\"\n</code>\n\nPractice combining lists, loops, conditionals, and functions to analyze the fragment data below.",
      "challenge": "Using the provided fragment lengths list, calculate statistics and count fragments by size categories to understand the distribution.",
      "data": "Fragment lengths (characters): [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\nCategories for analysis:\n‚Ä¢ Short fragments:     less than 30 characters\n‚Ä¢ Medium fragments:    30-60 characters  \n‚Ä¢ Long fragments:      more than 60 characters",
      "storyModifiers": {
        "secrecyPath": {
          "additionalContext": "\n\nDr. Rodriguez whispers: \"I found something. These fragment lengths... they match a known encryption pattern used by a secret society in the 3rd century. We might be dealing with intentionally hidden knowledge.\"",
          "bonusReveal": "The short fragments all contain warning words in ancient Greek!"
        },
        "scientificPath": {
          "additionalContext": "\n\nDr. Rodriguez's analysis revealed: \"The mathematical distribution is deliberate‚Äîit follows a Fibonacci-like sequence. This civilization understood advanced mathematics!\"",
          "bonusReveal": "Fragment lengths encode coordinates: 45.23¬∞N, 67.12¬∞E‚Äîan unexplored archaeological site!"
        }
      },
      "cells": [
        {
          "title": "Task 1: Count Total Fragments",
          "instruction": "Use the len() function to count how many fragments we have",
          "starterCode": "# Task 1: Count the total number of fragments\nfragment_lengths = [45, 23, 67, 12, 89, 34, 56, 78, 21, 43]\n\n# Use len() to count total fragments\n# TODO: Create a variable called total_fragments and set it to the length of fragment_lengths\n# TODO: Print the result using: \"Total fragments found: \" + str(total_fragments)",
          "expectedOutput": [
            "Total fragments found: 10"
          ],
          "validation": {
            "requiredNumbers": [
              10
            ],
            "requiredText": [
              "Total fragments found",
              "10"
            ],
            "outputPatterns": [
              "(Total fragments found.*10|10.*fragments found)",
              "Total fragments.*:.*10"
            ]
          },
          "hints": [
            "len() returns the number of items in a list",
            "Use len(fragment_lengths) to count the fragments",
            "Use str() to convert numbers to strings for concatenation",
            "Remember: \"text\" + str(number) for string concatenation"
          ]
        },
        {
          "title": "Task 2: Calculate Total Characters",
          "instruction": "Use a for loop to add up all the fragment lengths",
          "starterCode": "# Task 2: Calculate total characters using a for loop\n# Note: fragment_lengths is already available from Task 1\n\ntotal_characters = 0\n# TODO: Write a for loop to go through each length in fragment_lengths\n# TODO: In the loop, add each length to total_characters\n# TODO: Print the result using: \"Total characters: \" + str(total_characters)",
          "expectedOutput": [
            "Total characters: 468"
          ],
          "validation": {
            "requiredNumbers": [
              468
            ],
            "requiredText": [
              "Total characters",
              "468"
            ],
            "outputPatterns": [
              "(Total characters.*468|468.*Total characters)",
              "Total characters.*:.*468"
            ]
          },
          "hints": [
            "Use 'for length in fragment_lengths:' to loop through each length",
            "Add each length to total_characters inside the loop",
            "Use: total_characters = total_characters + length",
            "Use str() to convert the number to a string for concatenation"
          ]
        },
        {
          "title": "Task 3: Categorize Fragments",
          "instruction": "Create a function that categorizes fragments by size and returns the counts",
          "starterCode": "# Task 3: Create a function to categorize fragments by size\n# Note: fragment_lengths is still available from previous tasks\n\ndef categorize_fragments(lengths):\n    \"\"\"Categorize fragments by size and return counts.\n    \n    Args:\n        lengths: List of fragment lengths\n        \n    Returns:\n        tuple: (short_count, medium_count, long_count)\n            - short_count: fragments < 30 characters\n            - medium_count: fragments 30-60 characters  \n            - long_count: fragments > 60 characters\n    \"\"\"\n    short_count = 0\n    medium_count = 0\n    long_count = 0\n    \n    # TODO: Write a for loop to go through each length in the lengths parameter\n    # TODO: Use if/elif/else to check the length and increment the right counter\n    # TODO: Return the three counts as a tuple\n    \n    return short_count, medium_count, long_count\n\n# Test your function and display results\nshort, medium, long = categorize_fragments(fragment_lengths)\nprint(f\"Short fragments (< 30 chars): {short}\")\nprint(f\"Medium fragments (30-60 chars): {medium}\")\nprint(f\"Long fragments (> 60 chars): {long}\")",
          "expectedOutput": [
            "Short fragments (< 30 chars): 3",
            "Medium fragments (30-60 chars): 5",
            "Long fragments (> 60 chars): 2"
          ],
          "validation": {
            "requiredNumbers": [
              3,
              5,
              2
            ],
            "requiredText": [
              "Short fragments",
              "Medium fragments",
              "Long fragments"
            ],
            "outputPatterns": [
              "Short fragments.*3",
              "Medium fragments.*5",
              "Long fragments.*2"
            ],
            "codePatterns": [
              "def\\s+categorize_fragments\\s*\\(",
              "return\\s+.*short_count.*medium_count.*long_count",
              "for\\s+\\w+\\s+in\\s+lengths"
            ]
          },
          "hints": [
            "Define a function with def categorize_fragments(lengths):",
            "Use if/elif/else inside the for loop to categorize each length",
            "if length < 30: for short fragments",
            "elif length >= 30 and length <= 60: for medium fragments",
            "else: for long fragments",
            "Return all three counts: return short_count, medium_count, long_count",
            "The function call is already provided - just complete the function body"
          ]
        }
      ],
      "completionSegment": {
        "narrative": "Your analysis completes, and the pattern becomes clear. Dr. Rodriguez's eyes widen as she reviews your findings.\n\n\"This distribution isn't random at all! Look‚Äî\" She overlays your data with a map. \"The fragment lengths correspond to something else entirely. We're not just dealing with a text; this is a coded message system.\"\n\n{{pathSpecificRevelation}}\n\nShe takes a deep breath. \"We need to go deeper. But I should warn you‚Äîthe last person who investigated these fragments disappeared. Are you sure you want to continue?\"",
        "pathSpecificRevelations": {
          "secrecyPath": "The short fragments‚Äîall under 30 characters‚Äîthey're warnings. 'Danger.' 'Hidden.' 'Forbidden.' Someone was trying to keep people away from something.",
          "scientificPath": "The mathematical pattern in these lengths... it's encoding geographic coordinates! This civilization was mapping something across the ancient world."
        },
        "characterResponse": {
          "success": "\"Incredible work with those functions! {{playerAction}}. You're thinking like a true computational archaeologist.\"",
          "struggle": "\"Functions can be tricky at first, especially {{struggledConcept}}. But you pushed through‚Äîthat's what separates real researchers from dilettantes.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez looks serious. \"Before we proceed, I need to know your approach to potentially dangerous information:\"",
          "options": [
            {
              "id": "share_findings",
              "text": "We should document everything publicly for peer review",
              "consequence": "transparencyPath",
              "preview": "Open science approach‚Äîshare discoveries with the archaeological community",
              "modifiesStage": 3,
              "effect": "collaborationBonus"
            },
            {
              "id": "stay_secretive",
              "text": "We should keep this investigation confidential until we know more",
              "consequence": "secretPath",
              "preview": "Cautious approach‚Äîprotect sensitive information from misuse",
              "modifiesStage": 3,
              "effect": "mysteryBonus"
            }
          ]
        }
      },
      "solution": "# Full solution provided in original content",
      "hints": [
        "Use len(fragment_lengths) to count how many items are in the list",
        "For loops iterate through each item: for length in fragment_lengths:",
        "Inside the loop, add each length to your total: total_characters = total_characters + length",
        "Functions are defined with def function_name(parameters):",
        "Use if/elif/else inside loops: if length < 30: ... elif length <= 60: ... else:",
        "Functions should return values: return value1, value2, value3",
        "Remember to indent code inside function definitions, loops, and if/elif/else blocks (4 spaces)",
        "Comparison operators: < (less than), <= (less than or equal), > (greater than)"
      ]
    },
    {
      "id": 3,
      "title": "Decoding Fragment Languages",
      "story": "Some fragments appear to be in Latin, others in ancient Greek, and some are too damaged to identify. Understanding the language distribution might help us understand the cultural context.\n\n<strong>üîç Python Concepts: Conditional Statements and Functions</strong>\n\n<em>Conditional statements</em> let your program make decisions:\n‚Ä¢ <code>if</code> checks a condition: <code>if age >= 18:</code>\n‚Ä¢ <code>elif</code> checks additional conditions: <code>elif age >= 13:</code>\n‚Ä¢ <code>==</code> compares values (different from <code>=</code> which assigns)\n‚Ä¢ Remember to indent code inside if/elif blocks!\n\n<em>Functions</em> organize and structure your code:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return multiple values: <code>return value1, value2, value3</code>\n‚Ä¢ Call functions to get results: <code>latin, greek, unknown = count_languages(codes)</code>\n\nPractice using conditionals within functions to analyze language distribution.",
      "challenge": "Create a function that analyzes language codes and returns counts for each language type.",
      "data": "Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]",
      "storyModifiers": {
        "transparencyPath": {
          "additionalContext": "\n\nDr. Rodriguez shows you responses from colleagues worldwide: \"After sharing our initial findings, researchers in Rome and Athens found matching fragments! We're building a global picture.\"",
          "collaborators": [
            "Dr. Marcus Aurelius (Rome)",
            "Prof. Athena Dimitriou (Athens)"
          ],
          "bonusData": "Collaborative analysis reveals: LAT fragments contain legal texts, GRK fragments contain scientific formulas"
        },
        "secretPath": {
          "additionalContext": "\n\nDr. Rodriguez lowers her voice: \"Good call on staying quiet. I've detected someone trying to hack into our research server. Someone else is looking for these fragments.\"",
          "threat": "Unknown party attempting to access your data",
          "bonusData": "Secret pattern discovered: UNK (unknown) fragments aren't damaged‚Äîthey're in a third, unidentified language!"
        }
      },
      "starterCode": "# Create a function to count language types\n# Language codes: [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\n# LAT = Latin, GRK = Greek, UNK = Unknown\n\ndef count_languages(language_codes):\n    \"\"\"Count fragments by language type.\n    \n    Args:\n        language_codes: List of language codes (LAT, GRK, UNK)\n        \n    Returns:\n        tuple: (latin_count, greek_count, unknown_count)\n    \"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    # TODO: Write a for loop to go through each code in language_codes\n    # TODO: Use if/elif/else to check the code and increment the right counter\n    # TODO: Return the three counts as a tuple\n    \n    return latin_count, greek_count, unknown_count\n\n# Test your function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(f\"Latin fragments: {latin}\")\nprint(f\"Greek fragments: {greek}\")\nprint(f\"Unknown fragments: {unknown}\")",
      "solution": "def count_languages(language_codes):\n    \"\"\"Count fragments by language type.\"\"\"\n    latin_count = 0\n    greek_count = 0\n    unknown_count = 0\n    \n    for lang in language_codes:\n        if lang == \"LAT\":\n            latin_count += 1\n        elif lang == \"GRK\":\n            greek_count += 1\n        elif lang == \"UNK\":\n            unknown_count += 1\n    \n    return latin_count, greek_count, unknown_count\n\n# Test the function\nlanguages = [\"LAT\", \"GRK\", \"UNK\", \"LAT\", \"UNK\", \"LAT\", \"GRK\", \"LAT\", \"UNK\", \"GRK\", \"LAT\", \"UNK\"]\nlatin, greek, unknown = count_languages(languages)\n\nprint(f\"Latin fragments: {latin}\")\nprint(f\"Greek fragments: {greek}\")\nprint(f\"Unknown fragments: {unknown}\")",
      "validation": {
        "codePatterns": [
          "def\\s+count_languages\\s*\\(",
          "language_codes",
          "return\\s+.*latin_count.*greek_count.*unknown_count",
          "for\\s+\\w+\\s+in\\s+language_codes",
          "if\\s+.*==.*['\"]LAT['\"]",
          "elif\\s+.*==.*['\"]GRK['\"]"
        ],
        "outputPatterns": [
          "(Latin fragments.*5|5.*Latin)",
          "(Greek fragments.*3|3.*Greek)",
          "(Unknown fragments.*4|4.*Unknown)"
        ],
        "description": "Must create a function that counts language types and returns the counts"
      },
      "hints": [
        "Define the function with def count_languages(language_codes):",
        "Use a for loop inside the function: for lang in language_codes:",
        "Use if/elif/else to categorize: if lang == \"LAT\":",
        "Increment counters: latin_count += 1",
        "Return all three counts: return latin_count, greek_count, unknown_count",
        "The function call is already provided - just complete the function body"
      ],
      "completionSegment": {
        "narrative": "The language analysis completes, revealing an unexpected pattern. Dr. Rodriguez's face goes pale.\n\n\"This changes everything. The mix of Latin and Greek isn't random‚Äîit's a diplomatic cipher used only during one specific period: the Crisis of the Third Century. But these unknown fragments...\"\n\nShe pulls up a linguistic database. \"They match no known ancient language. Either we're dealing with a completely lost dialect, or...\" She pauses. \"Or this is something else entirely. A constructed language, perhaps. A code within a code.\"\n\n{{pathSpecificDiscovery}}",
        "pathSpecificDiscoveries": {
          "transparencyPath": "Your collaborator in Athens just sent an urgent message: 'The unknown fragments match star positions! This civilization was encoding astronomical data!'",
          "secretPath": "A private message flashes on your screen: 'Stop digging or face consequences.' But there's more‚Äîthe message is written in the same unknown language as the fragments!"
        },
        "characterResponse": {
          "success": "\"Perfect implementation of that language counter! {{playerAction}} shows you understand both the code and the archaeological implications.\"",
          "struggle": "\"Language patterns are complex, and {{struggledConcept}} can be confusing. But you've identified something crucial here.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez turns to you with urgency. \"We're at a crossroads. How should we proceed with these unknown fragments?\"",
          "options": [
            {
              "id": "linguistic_ai",
              "text": "Use AI to attempt decoding the unknown language",
              "consequence": "technologyPath",
              "preview": "Leverage modern technology to crack ancient codes",
              "unlocksAbility": "aiAssistance"
            },
            {
              "id": "historical_research",
              "text": "Cross-reference with historical events from that time period",
              "consequence": "historicalPath",
              "preview": "Use traditional archaeological methods and historical context",
              "unlocksAbility": "contextualClues"
            }
          ]
        }
      }
    },
    {
      "id": 4,
      "title": "Dating the Fragments",
      "story": "Carbon dating and paleographic analysis have provided approximate dates for each fragment. Understanding the temporal distribution might reveal when this civilization flourished.\n\n<strong>üîç Python Concepts: Functions, Min/Max Finding, and Range Analysis</strong>\n\n<em>Functions</em> help organize complex analysis tasks:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return multiple values: <code>return value1, value2</code>\n‚Ä¢ Functions make code reusable and testable\n\n<em>Finding minimum and maximum values:</em>\n‚Ä¢ Start with first item: <code>oldest = dates[0]</code>\n‚Ä¢ Compare in loops: <code>if date < oldest:</code>\n‚Ä¢ Update when finding new extremes: <code>oldest = date</code>\n\n<em>Range checking with conditions:</em>\n‚Ä¢ Combine conditions: <code>if date >= 100 and date < 200:</code>\n‚Ä¢ Use elif for multiple ranges\n‚Ä¢ Count items that meet criteria",
      "challenge": "Create functions to analyze fragment dating data and determine temporal distribution patterns.",
      "data": "Fragment dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]",
      "storyModifiers": {
        "technologyPath": {
          "additionalContext": "\n\nThe AI analysis returns shocking results: \"Language pattern identified. 87% probability: Modified Proto-Indo-European with mathematical notation embedded. This civilization encoded equations in their language structure!\"",
          "techDiscovery": "Each date corresponds to a astronomical event‚Äîeclipses, planetary alignments"
        },
        "historicalPath": {
          "additionalContext": "\n\nYour historical research uncovers a pattern: \"Every date matches a documented crisis or disaster. 150 CE: Antonine Plague begins. 230 CE: Crisis of the Third Century. They were documenting catastrophes!\"",
          "historyDiscovery": "The fragments are a survival guide for future civilizations"
        }
      },
      "starterCode": "# Create functions to analyze fragment dating patterns\n# Dates (CE): [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\ndef find_date_range(dates):\n    \"\"\"Find the oldest and newest dates in the collection.\n    \n    Args:\n        dates: List of dates (integers)\n        \n    Returns:\n        tuple: (oldest_date, newest_date)\n    \"\"\"\n    # TODO: Initialize oldest and newest with the first date\n    # TODO: Loop through all dates to find min and max\n    # TODO: Return both values as a tuple\n    \n    return oldest_date, newest_date\n\ndef count_by_century(dates):\n    \"\"\"Count fragments by century periods.\n    \n    Args:\n        dates: List of dates (integers)\n        \n    Returns:\n        tuple: (second_century_count, third_century_count, fourth_century_count)\n    \"\"\"\n    second_century = 0  # 100-199 CE\n    third_century = 0   # 200-299 CE\n    fourth_century = 0  # 300-399 CE\n    \n    # TODO: Loop through dates and categorize by century\n    # TODO: Use if/elif/else to count each century\n    # TODO: Return all three counts\n    \n    return second_century, third_century, fourth_century\n\n# Test your functions\ndates = [150, 230, 180, 340, 290, 160, 380, 200, 220, 310]\n\n# Analyze date range\noldest, newest = find_date_range(dates)\nprint(f\"Date range: {oldest} CE to {newest} CE\")\nprint(f\"Time span: {newest - oldest} years\")\n\n# Analyze by century\nsecond, third, fourth = count_by_century(dates)\nprint(f\"2nd century (100-199 CE): {second} fragments\")\nprint(f\"3rd century (200-299 CE): {third} fragments\")\nprint(f\"4th century (300-399 CE): {fourth} fragments\")",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "def\\s+find_date_range\\s*\\(",
          "def\\s+count_by_century\\s*\\(",
          "return\\s+.*oldest_date.*newest_date",
          "return\\s+.*second_century.*third_century.*fourth_century",
          "for\\s+\\w+\\s+in\\s+dates",
          "if\\s+date\\s+<\\s+oldest_date",
          "if\\s+date\\s+>\\s+newest_date",
          "if\\s+date\\s+>=\\s+100\\s+and\\s+date\\s+<\\s+200"
        ],
        "outputPatterns": [
          "Date range.*150.*380.*CE",
          "Time span.*230.*years",
          "2nd century.*100-199.*2.*fragments",
          "3rd century.*200-299.*4.*fragments",
          "4th century.*300-399.*4.*fragments"
        ],
        "description": "Must create functions for date range analysis and century counting"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Start min/max with first item: oldest_date = dates[0]",
        "Compare in loops: if date < oldest_date: oldest_date = date",
        "For century ranges: if date >= 100 and date < 200:",
        "Return multiple values: return value1, value2, value3",
        "The function calls are provided - complete the function bodies"
      ],
      "completionSegment": {
        "narrative": "The temporal analysis reveals a chilling pattern. Dr. Rodriguez stares at the results, her hands trembling slightly.\n\n\"230 years... That's not just a time span. That's almost exactly eight generations. In many ancient cultures, eight generations was considered a complete cycle of cultural memory.\"\n\n{{pathSpecificRevelation}}\n\nShe stands up abruptly. \"We need to make a decision. I've just received word that a team of 'private collectors' is heading to the Alexandria archives tomorrow. They're after the physical fragments.\"",
        "pathSpecificRevelations": {
          "technologyPath": "Your AI-enhanced analysis confirms it: 'The dates form a predictive model. The civilization was calculating future events. The next predicted date is... next month.'",
          "historicalPath": "Your historical research reveals the truth: 'They weren't just recording disasters‚Äîthey were recording successful responses to them. This is a survival manual.'"
        },
        "characterResponse": {
          "success": "\"Your date analysis is flawless. {{playerAction}} particularly impressed me‚Äîyou're thinking beyond the code to the meaning.\"",
          "struggle": "\"Dating analysis involves complex logic, and {{struggledConcept}} is a common challenge. But your persistence revealed something crucial.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez looks you straight in the eye. \"We can try to protect the fragments, or we can focus on decoding them before it's too late. What's your call?\"",
          "options": [
            {
              "id": "protect_fragments",
              "text": "Secure the physical fragments first",
              "consequence": "preservationPath",
              "preview": "Race to Alexandria to safeguard the artifacts",
              "addsUrgency": true
            },
            {
              "id": "decode_priority",
              "text": "Focus on decoding‚Äîthe information matters more than the artifacts",
              "consequence": "knowledgePath",
              "preview": "Let others chase fragments while we chase meaning",
              "addsComplexity": true
            }
          ]
        }
      }
    },
    {
      "id": 5,
      "title": "Word Frequency Analysis",
      "story": "You've transcribed some key words from the legible fragments. Analyzing word frequency might reveal important themes or repeated concepts in this ancient text.\n\n<strong>üîç Python Concepts: Dictionary-like Counting and Functions</strong>\n\n<em>Functions</em> help organize data analysis tasks:\n‚Ä¢ Define with <code>def function_name(parameters):</code>\n‚Ä¢ Return structured data: <code>return counts_dict</code>\n‚Ä¢ Functions make analysis reusable and clear\n\n<em>Counting with variables (simulating dictionary behavior):</em>\n‚Ä¢ Use separate variables for each category\n‚Ä¢ Compare strings with <code>==</code>: <code>if word == \"temple\":</code>\n‚Ä¢ Increment counters: <code>temple_count += 1</code>\n‚Ä¢ Track maximum values for analysis",
      "challenge": "Create a function to analyze word frequencies and identify the most common themes in the fragments.",
      "data": "Words found: [\"temple\", \"gold\", \"sacred\", \"temple\", \"ritual\", \"gold\", \"temple\", \"sacred\", \"gold\", \"temple\", \"ritual\", \"sacred\"]",
      "storyModifiers": {
        "preservationPath": {
          "additionalContext": "\n\nDr. Rodriguez messages from Alexandria: \"We secured the fragments just in time! But look at this‚Äîhidden writing appears under UV light. These new words change everything!\"",
          "bonusWords": [
            "escape",
            "underground",
            "preservation",
            "future"
          ],
          "urgentNote": "Time pressure increases‚Äîanalyze quickly!"
        },
        "knowledgePath": {
          "additionalContext": "\n\nWhile others chase fragments, your deep analysis pays off: \"The word frequencies follow a mathematical pattern. It's not just what they're saying, but how often‚Äîit's another layer of encoding!\"",
          "patternDiscovered": "Word frequency ratios: 4:3:3:2 = Musical intervals!",
          "insight": "They encoded music in their text frequency"
        }
      },
      "starterCode": "[Original starter code here]",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_word_frequency\\s*\\(",
          "def\\s+find_most_common_word\\s*\\(",
          "return\\s+.*temple_count.*gold_count.*sacred_count.*ritual_count",
          "return\\s+.*most_common_word.*highest_count",
          "for\\s+\\w+\\s+in\\s+words",
          "if\\s+word\\s+==\\s+['\"]temple['\"]",
          "if\\s+.*_count\\s+>\\s+highest_count"
        ],
        "outputPatterns": [
          "Word frequencies",
          "temple.*4",
          "gold.*3",
          "sacred.*3",
          "ritual.*2",
          "Most common word.*temple.*4"
        ],
        "description": "Must create functions for word frequency analysis and finding maximum"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use if/elif to categorize words: if word == \"temple\":",
        "Increment counters: temple_count += 1",
        "For finding max, start with first as highest",
        "Compare each count: if gold_count > highest_count:",
        "Update both word and count when finding new maximum",
        "Return multiple values: return value1, value2, value3, value4"
      ],
      "completionSegment": {
        "narrative": "The word frequency analysis completes, and suddenly the pattern becomes crystal clear. Dr. Rodriguez gasps.\n\n\"Temple, gold, sacred, ritual... This isn't religious text. It's instructions! They're describing how to preserve knowledge using temple gold‚Äîa metal that doesn't corrode‚Äîinscribed with sacred rituals that ensure the knowledge is maintained.\"\n\n{{pathSpecificInsight}}\n\n\"We're close to understanding their complete message. But I need to share something with you...\" Dr. Rodriguez looks uncomfortable. \"I haven't been entirely honest about how I found these fragments.\"",
        "pathSpecificInsights": {
          "preservationPath": "The UV-revealed words confirm it: 'escape,' 'underground,' 'preservation'‚Äîthey were fleeing something catastrophic and left instructions for survivors!",
          "knowledgePath": "The musical encoding in the frequencies isn't decorative‚Äîit's functional. When the frequencies are played as notes, they form a mathematical sequence that unlocks the next layer of the cipher!"
        },
        "characterResponse": {
          "success": "\"Your frequency analysis is brilliant! {{playerAction}} revealed exactly what we needed. You have a natural talent for pattern recognition.\"",
          "struggle": "\"Frequency analysis requires careful tracking, and {{struggledConcept}} added complexity. But you found the pattern that unlocks everything.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez takes a deep breath. \"I found these fragments because... I was following clues left by my grandmother. She was part of a society that's been protecting this knowledge for generations. Now I need to know‚Äîcan I trust you with the complete truth?\"",
          "options": [
            {
              "id": "demand_truth",
              "text": "I need to know everything before we continue",
              "consequence": "truthPath",
              "preview": "Insist on full disclosure about the secret society",
              "revealsBackstory": true
            },
            {
              "id": "trust_rodriguez",
              "text": "Your grandmother's legacy is safe with me‚Äîlet's finish this together",
              "consequence": "trustPath",
              "preview": "Build alliance based on mutual trust",
              "strengthensRelationship": true
            }
          ]
        }
      }
    },
    {
      "id": 6,
      "title": "Fragment Reconstruction",
      "story": "Some fragments appear to be parts of the same document. By analyzing character patterns and common sequences, you can identify which fragments belong together.\n\n<strong>üîç Python Concepts: String Methods and Boolean Logic</strong>\n\nWorking with text strings:\n‚Ä¢ <code>.startswith()</code> checks how a string begins: <code>text.startswith(\"The\")</code>\n‚Ä¢ <code>.endswith()</code> checks how a string ends: <code>text.endswith(\"end\")</code>\n‚Ä¢ <code>in</code> checks if text contains something: <code>\"temple\" in text</code>\n‚Ä¢ <code>and</code> combines conditions: <code>if condition1 and condition2:</code>\n\nPractice using string methods to match and categorize fragment patterns.",
      "challenge": "Analyze fragments to find matching patterns and group related pieces together.",
      "data": "Fragment texts: [\"The sacred temple\", \"temple was built\", \"In ancient times\", \"times were different\", \"The golden altar\", \"altar stood tall\"]",
      "storyModifiers": {
        "truthPath": {
          "additionalContext": "\n\nDr. Rodriguez reveals: \"The society is called the Keepers of Alexandria. For 1,700 years, we've been waiting for someone with the skills to decode these fragments. My grandmother believed that person would emerge when the world needed this knowledge most.\"",
          "societySecret": "The Keepers have fragments hidden in 12 locations worldwide",
          "responsibility": "You're now being invited to join the Keepers"
        },
        "trustPath": {
          "additionalContext": "\n\nDr. Rodriguez smiles with relief: \"Your trust means everything. Together, we can finish what my grandmother started. She left me one final clue‚Äîa fragment she kept hidden that connects all the others.\"",
          "hiddenFragment": "The master key: 'When temple gold preserves the sacred ritual, time's spiral completes'",
          "bond": "Dr. Rodriguez now fully trusts you as a partner"
        }
      },
      "starterCode": "[Original starter code here]",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "fragments\\s*=\\s*\\[.*\\]",
          "for\\s+\\w+\\s+in\\s+fragments",
          "if\\s+['\"]temple['\"]\\s+in\\s+\\w+",
          "(temple_fragments|times_fragments|altar_fragments)",
          "range\\(len\\(fragments\\)\\)"
        ],
        "outputPatterns": [
          "Temple fragment.*The sacred temple",
          "Temple fragment.*temple was built",
          "Times fragment.*In ancient times",
          "Times fragment.*times were different",
          "Altar fragment.*The golden altar",
          "Altar fragment.*altar stood tall"
        ],
        "description": "Must group fragments by common words and find connections"
      },
      "hints": [
        "Use 'in' to check if a word appears in a fragment: if \"temple\" in fragment:",
        "Use .split() to break text into words: fragment.split()",
        "fragment.split()[-1] gets the last word of a fragment",
        "Compare fragments in nested loops to find connections",
        "Use != to check if indices are different: if i != j:"
      ],
      "completionSegment": {
        "narrative": "The reconstruction algorithm reveals the fragments' true structure. They connect in a specific sequence, forming a larger message. Dr. Rodriguez's eyes fill with tears.\n\n\"It's beautiful. They didn't just preserve knowledge‚Äîthey created a system that would only reveal itself to someone who understood both ancient languages AND modern programming. They predicted the rise of computational analysis!\"\n\n{{pathSpecificRevelation}}\n\nThe reconstructed message begins to glow on your screen, quite literally‚Äîthe code is triggering something in the display system.",
        "pathSpecificRevelations": {
          "truthPath": "As a potential Keeper, you now see the hidden layer: The fragments contain quantum entanglement patterns. This ancient civilization understood principles we're only now discovering!",
          "trustPath": "The master fragment Dr. Rodriguez shared completes the puzzle: The message is a blueprint for a device that preserves information across millennia using crystallized gold structures."
        },
        "characterResponse": {
          "success": "\"Your string manipulation is elegant! {{playerAction}} shows mastery of both the technical and interpretive skills needed for digital archaeology.\"",
          "struggle": "\"String operations and {{struggledConcept}} can be challenging, but you've reconstructed something that's been broken for nearly two thousand years!\""
        },
        "choice": {
          "prompt": "The screen flashes with an urgent message: 'COMPLETE ACTIVATION SEQUENCE? This action will broadcast the decoded knowledge globally. Proceed?'",
          "options": [
            {
              "id": "activate_broadcast",
              "text": "Yes‚Äîshare this knowledge with humanity",
              "consequence": "enlightenmentPath",
              "preview": "Release ancient wisdom to the world",
              "globalImpact": true
            },
            {
              "id": "secure_knowledge",
              "text": "No‚Äîthis needs to be studied carefully first",
              "consequence": "guardianPath",
              "preview": "Protect knowledge until humanity is ready",
              "createsResponsibility": true
            }
          ]
        }
      }
    },
    {
      "id": 7,
      "title": "Geographic Distribution",
      "story": "The fragments were found at different archaeological sites. Understanding their geographic distribution might reveal trade routes or cultural connections.\n\n<strong>üîç Python Concepts: Functions, Parallel Lists, and Statistical Analysis</strong>",
      "challenge": "Create functions to analyze geographic distribution and calculate site statistics.",
      "data": "Sites: [\"Alexandria\", \"Memphis\", \"Thebes\", \"Aswan\"]\nFragment counts: [15, 8, 12, 5]",
      "storyModifiers": {
        "enlightenmentPath": {
          "additionalContext": "\n\nThe global broadcast has begun. Responses are pouring in from archaeological sites worldwide: 'We have matching fragments!' The puzzle is bigger than anyone imagined‚Äîthis civilization left messages across the entire ancient world!",
          "worldResponse": "UNESCO declares this the most significant archaeological discovery in human history",
          "newSites": [
            "Rome",
            "Athens",
            "Carthage",
            "Babylon",
            "Persepolis"
          ]
        },
        "guardianPath": {
          "additionalContext": "\n\nYou've chosen the path of wisdom. But others have detected the activation prompt. Multiple parties are converging on your location, all wanting the knowledge for different purposes.",
          "threats": [
            "Corporate data miners",
            "Government agencies",
            "Treasure hunters"
          ],
          "allies": "The Keepers of Alexandria stand ready to help protect the knowledge"
        }
      },
      "starterCode": "[Original starter code here]",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "def\\s+calculate_site_statistics\\s*\\(",
          "def\\s+find_major_sites\\s*\\(",
          "return\\s+.*total_fragments.*site_statistics",
          "return\\s+.*top_site.*top_count.*major_sites",
          "sum\\(counts\\)",
          "range\\(len\\(sites\\)\\)",
          "sites\\[i\\]",
          "counts\\[i\\]",
          "round\\(.*\\*\\s*100.*\\)"
        ],
        "outputPatterns": [
          "Total fragments.*40",
          "Alexandria.*15.*37\\.5",
          "Memphis.*8.*20\\.0",
          "Thebes.*12.*30\\.0",
          "Aswan.*5.*12\\.5",
          "Most fragments found at.*Alexandria.*15",
          "Major sites.*‚â•10.*2.*sites",
          "- Alexandria",
          "- Thebes"
        ],
        "description": "Must create functions for geographic analysis with parallel lists and statistics"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use sum(counts) to calculate total",
        "Use range(len(sites)) to loop through indices",
        "Access parallel data: sites[i] and counts[i]",
        "Calculate percentage: (count / total) * 100",
        "Use round(percentage, 1) for formatting",
        "Find max by comparing: if counts[i] > top_count:",
        "Create lists with .append(): major_sites.append(site)"
      ],
      "completionSegment": {
        "narrative": "The geographic analysis reveals a stunning truth. The sites form a perfect geometric pattern when plotted on a map‚Äîa pentagram with Alexandria at its heart.\n\nDr. Rodriguez pulls up an ancient star chart. \"These sites align with the constellation Draco as it appeared in 250 CE. They built a map of the heavens on Earth!\"\n\n{{pathSpecificDevelopment}}\n\n\"We're approaching the culmination of everything we've discovered. The final stage will require everything you've learned.\"",
        "pathSpecificDevelopments": {
          "enlightenmentPath": "The worldwide revelation has triggered something unexpected: Ancient sites across the globe are resonating with electromagnetic energy. The fragments weren't just messages‚Äîthey're components of a planetary-scale device!",
          "guardianPath": "Your decision to protect the knowledge has paid off. The Keepers reveal that each site contains a hidden chamber with more fragments. But you must choose which site to excavate first, knowing others are watching."
        },
        "characterResponse": {
          "success": "\"Your geographic analysis is masterful! {{playerAction}} particularly‚Äîyou've revealed a pattern hidden for two millennia.\"",
          "struggle": "\"Geographic data analysis with {{struggledConcept}} is complex, but you've uncovered the celestial connection we needed.\""
        },
        "choice": {
          "prompt": "Dr. Rodriguez shows you the final piece of the puzzle: 'The geographic pattern points to a central location we haven't excavated yet‚Äîa place where all the knowledge converges. But reaching it means making a choice about how this story ends.'",
          "options": [
            {
              "id": "seek_source",
              "text": "Journey to the convergence point immediately",
              "consequence": "discoveryEnding",
              "preview": "Race to uncover the source of all fragments",
              "leadsToEnding": "seeker"
            },
            {
              "id": "protect_sites",
              "text": "Secure all known sites before proceeding",
              "consequence": "guardianEnding",
              "preview": "Ensure the knowledge is preserved for future generations",
              "leadsToEnding": "guardian"
            },
            {
              "id": "share_coordinates",
              "text": "Publish the convergence point coordinates for all humanity",
              "consequence": "enlightenmentEnding",
              "preview": "Let the world join in the final discovery",
              "leadsToEnding": "savior"
            }
          ]
        }
      }
    },
    {
      "id": 8,
      "title": "Digital Restoration",
      "story": "Using digital imaging techniques, you've recovered some damaged text. The restoration process involves analyzing character patterns and filling in gaps based on context.\n\n<strong>üîç Python Concepts: Functions and String Processing</strong>",
      "challenge": "Create functions to systematically restore damaged text and calculate restoration statistics.",
      "data": "Damaged text: \"th? s?cr?d t?mpl? w?s b??lt ?n ?nc??nt t?m?s\"",
      "storyModifiers": {
        "discoveryEnding": {
          "additionalContext": "\n\nYou're racing against time to the convergence point. Your restoration algorithm will be crucial‚Äîthe final message is heavily damaged, and only perfect restoration will reveal the ultimate truth.",
          "pressure": "Other parties are hours behind you",
          "stakes": "First to decode wins everything"
        },
        "guardianEnding": {
          "additionalContext": "\n\nAs you secure each site, you find more damaged texts. Your restoration work is preserving knowledge that would otherwise be lost forever. The Keepers are documenting everything.",
          "legacy": "Your methods will teach future generations",
          "responsibility": "You're becoming the knowledge keeper"
        },
        "enlightenmentEnding": {
          "additionalContext": "\n\nThe world watches as you restore the damaged text live. Millions are following your code, learning both programming and archaeology. You're not just revealing history‚Äîyou're teaching it.",
          "audience": "Global livestream with 100 million viewers",
          "impact": "Inspiring a new generation of digital archaeologists"
        }
      },
      "starterCode": "[Original starter code here]",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "def\\s+analyze_damage\\s*\\(",
          "def\\s+restore_text\\s*\\(",
          "return\\s+.*total_chars.*damaged_chars.*damage_percentage",
          "return\\s+.*final_text.*total_steps",
          "\\.count\\(['\"]\\?['\"]\\)",
          "len\\(.*\\)",
          "\\.replace\\(",
          "\\.capitalize\\(\\)",
          "round\\(.*\\*\\s*100.*\\)"
        ],
        "outputPatterns": [
          "=== DIGITAL RESTORATION ANALYSIS ===",
          "Original damaged text.*th\\?.*t\\?m\\?s",
          "Total characters.*42",
          "Damaged characters.*13",
          "Damage level.*30\\.9",
          "Restoration complete.*8.*steps",
          "Final restored text.*The sacred temple was built in ancient times",
          "Text length.*42.*‚Üí.*46",
          "Characters restored.*13"
        ],
        "description": "Must create functions for text restoration with damage analysis and systematic replacement"
      },
      "hints": [
        "Define functions with def function_name(parameters):",
        "Use .count(\"?\") to count damaged characters",
        "Use len(text) to get total character count",
        "Calculate percentage: (damaged / total) * 100",
        "Chain replacements: step1 = text.replace(...), step2 = step1.replace(...)",
        "Use .capitalize() for final formatting",
        "Return multiple values: return value1, value2, value3",
        "Track the number of replacement operations performed"
      ],
      "completionSegment": {
        "narrative": "The restoration completes perfectly. The ancient text reveals its final secret:\n\n'The sacred temple was built in ancient times... to preserve the echo of stars, the memory of mathematics, the soul of science. We are the Bridge Builders, connecting past to future. Our civilization ends, but our knowledge endures. To you who can read this: you are our descendants, not in blood, but in mind. Build your own bridges.'\n\n{{pathSpecificClimax}}\n\nDr. Rodriguez turns to you, tears streaming down her face. \"We did it. We actually did it.\"",
        "pathSpecificClimaxes": {
          "discoveryEnding": "At the convergence point, your restored text activates an ancient device. A holographic library materializes‚Äîcontaining the complete knowledge of the lost civilization. You stand in awe as centuries of wisdom unfold before you.",
          "guardianEnding": "Your careful preservation ensures the knowledge survives. The Keepers make you their new leader, entrusting you with fragments from around the world. You'll spend your life protecting and sharing this wisdom.",
          "enlightenmentEnding": "As millions watch your restoration, something miraculous happens: People worldwide begin finding new fragments, inspired by your work. The ancient civilization's dream is realized‚Äîtheir knowledge truly belongs to all humanity."
        },
        "characterResponse": {
          "success": "\"Your restoration algorithm is perfect! {{playerAction}} brought ancient words back to life. You've mastered both the technical craft and the art of digital archaeology.\"",
          "struggle": "\"Text restoration and {{struggledConcept}} pushed your skills to the limit, but you've achieved something remarkable‚Äîyou've given voice to the past.\""
        }
      }
    },
    {
      "id": 9,
      "title": "The Final Revelation",
      "story": "All your analysis has led to this moment. By combining the data from all previous stages, you can now piece together the complete story of this ancient civilization.\n\n<strong>üîç Python Concepts: Bringing It All Together</strong>\n\nSynthesizing your skills:\n‚Ä¢ Use all the concepts you've learned: variables, lists, loops, conditionals\n‚Ä¢ Combine data from multiple sources\n‚Ä¢ Create comprehensive analysis reports\n‚Ä¢ Present findings in a clear, organized format\n\nThis final challenge tests your mastery of all Python fundamentals covered in this adventure.",
      "challenge": "Create a comprehensive analysis report combining insights from all your previous investigations.",
      "data": "Final data synthesis using all previous findings:\n‚Ä¢ Fragment analysis\n‚Ä¢ Language distribution\n‚Ä¢ Dating results\n‚Ä¢ Word frequencies\n‚Ä¢ Geographic distribution",
      "starterCode": "[Original starter code here]",
      "solution": "[Original solution code here]",
      "validation": {
        "codePatterns": [
          "total_fragments\\s*=\\s*40",
          "languages\\s*=\\s*\\[.*Latin.*Greek.*Unknown.*\\]",
          "language_counts\\s*=\\s*\\[.*18.*15.*7.*\\]",
          "date_range\\s*=\\s*\\[.*150.*380.*\\]",
          "for\\s+i\\s+in\\s+range\\(",
          "percentage\\s*=.*sum\\(",
          "round\\(",
          "print\\(f.*\\{.*\\}.*\\)"
        ],
        "outputPatterns": [
          "üèõÔ∏è DIGITAL ARCHAEOLOGY FINAL REPORT",
          "Total fragments discovered.*40",
          "Date range.*150.*380.*CE",
          "Time span.*230.*years",
          "Latin.*18.*45\\.0",
          "Greek.*15.*37\\.5",
          "Unknown.*7.*17\\.5",
          "Alexandria.*15.*37\\.5",
          "temple.*12.*occurrences",
          "MISSION ACCOMPLISHED",
          "Most significant site.*Alexandria.*15",
          "Most common theme.*temple.*12",
          "Primary languages.*Latin.*Greek",
          "Research period.*230.*years"
        ],
        "description": "Must create comprehensive report using all programming concepts learned"
      },
      "hints": [
        "Combine data from all previous stages",
        "Use lists to organize related information",
        "Calculate percentages: (count / total) * 100",
        "Use loops to process multiple pieces of data",
        "Present findings in a clear, organized report format",
        "Use string formatting to create professional output"
      ],
      "completionSegment": {
        "narrative": "Your final report compiles everything discovered on this incredible journey. The complete picture emerges:\n\nThe Bridge Builders were a secret society of scholars who foresaw the fall of classical civilization. They preserved not just knowledge, but a METHOD of thinking‚Äîcomputational thinking‚Äîencoded in a way that only a future technological civilization could decode.\n\nThey predicted that when humanity redeveloped computing, someone would find their fragments and understand their message: Knowledge transcends time when preserved with wisdom and shared with purpose.\n\n{{ending}}",
        "characterResponse": {
          "success": "\"You've done more than solve a mystery‚Äîyou've bridged two thousand years of human knowledge. {{playerAction}} throughout this journey proved you're a true digital archaeologist. My grandmother would be so proud.\"",
          "struggle": "\"Through every challenge, including {{struggledConcept}}, you persevered. That's what makes a real archaeologist‚Äînot perfection, but persistence. You've honored both the ancient scholars and modern science.\""
        }
      }
    }
  ],
  "endings": {
    "seeker": {
      "id": "seeker",
      "title": "The Seeker",
      "requirements": [
        "pursued_mystery",
        "sought_convergence",
        "chose_discovery"
      ],
      "narrative": "At the convergence point, you discover the Bridge Builders still exist‚Äîdescendants who've waited centuries for someone with your unique skills. They invite you to join them in preserving knowledge for future civilizations. You accept, becoming a bridge between past and future.\n\nDr. Rodriguez smiles. 'My grandmother always said the right person would know what to do. She was right about you.'\n\nYour Python skills and archaeological instincts have uncovered not just ancient history, but a living legacy. You are now part of something greater‚Äîa guardian of human knowledge across time.",
      "badge": "seeker_badge",
      "description": "You followed the mystery to its source and joined an ancient tradition"
    },
    "guardian": {
      "id": "guardian",
      "title": "The Guardian",
      "requirements": [
        "chose_preservation",
        "protected_sites",
        "secured_knowledge"
      ],
      "narrative": "Your careful preservation of each site ensures the fragments survive for future generations. The Keepers of Alexandria recognize your wisdom and dedication, naming you the Chief Digital Archivist.\n\nUnder your leadership, a global network forms to protect and study the Bridge Builders' legacy. Museums worldwide showcase your discoveries, but the deepest secrets remain protected, waiting for humanity to be ready.\n\nDr. Rodriguez stays by your side as your partner. Together, you've saved priceless knowledge from being lost or misused.",
      "badge": "guardian_badge",
      "description": "You became the protector of ancient wisdom and founded a new order of digital archaeologists"
    },
    "savior": {
      "id": "savior",
      "title": "The Savior",
      "requirements": [
        "shared_knowledge",
        "chose_enlightenment",
        "helped_humanity"
      ],
      "narrative": "By sharing the Bridge Builders' knowledge freely, you trigger a global renaissance. Their preserved mathematics advances quantum computing by decades. Their astronomical data reveals patterns that revolutionize our understanding of climate cycles, helping prevent future disasters.\n\nThe world remembers you not as the person who found the knowledge, but as the one who gave it away. Schools teach the 'Rodriguez-[YourName] Method' of computational archaeology.\n\nDr. Rodriguez establishes a foundation in both your names, ensuring the Bridge Builders' dream lives on: knowledge belongs to all humanity.",
      "badge": "savior_badge",
      "description": "You gifted ancient wisdom to the world, sparking a new age of enlightenment"
    },
    "scholar": {
      "id": "scholar",
      "title": "The Scholar",
      "requirements": [
        "focused_on_translation",
        "chose_research",
        "valued_understanding"
      ],
      "narrative": "Your meticulous analysis becomes the definitive academic work on the Bridge Builders. Years of careful study reveal layer after layer of meaning in their fragments‚Äîmathematical theorems, astronomical observations, even early quantum theory.\n\nYou become the world's leading expert, teaching at Alexandria's rebuilt library. Your students use your Python programs to make new discoveries, continuing your work.\n\nDr. Rodriguez writes in her final letter: 'You chose understanding over glory, wisdom over wealth. The Bridge Builders would recognize you as one of their own‚Äîa true scholar.'",
      "badge": "scholar_badge",
      "description": "You devoted your life to understanding and teaching the ancient knowledge"
    }
  },
  "narrativePaths": {
    "secrecyPath": {
      "description": "Following the trail of hidden knowledge",
      "modifiesStages": [
        2,
        3,
        4
      ],
      "unlocks": [
        "secretSocietyRevelation",
        "hiddenDangers"
      ]
    },
    "scientificPath": {
      "description": "Using data analysis to reveal patterns",
      "modifiesStages": [
        2,
        3,
        4
      ],
      "unlocks": [
        "mathematicalCiphers",
        "astronomicalConnections"
      ]
    },
    "transparencyPath": {
      "description": "Sharing discoveries with the global community",
      "modifiesStages": [
        3,
        4,
        5
      ],
      "unlocks": [
        "globalCollaboration",
        "publicSupport"
      ]
    },
    "technologyPath": {
      "description": "Leveraging AI and modern tools",
      "modifiesStages": [
        4,
        5,
        6
      ],
      "unlocks": [
        "aiAssistance",
        "quantumPatterns"
      ]
    },
    "preservationPath": {
      "description": "Racing to protect physical artifacts",
      "modifiesStages": [
        5,
        6,
        7
      ],
      "unlocks": [
        "urgentAction",
        "hiddenArtifacts"
      ]
    },
    "knowledgePath": {
      "description": "Prioritizing understanding over artifacts",
      "modifiesStages": [
        5,
        6,
        7
      ],
      "unlocks": [
        "deeperMeaning",
        "theoreticalBreakthroughs"
      ]
    }
  }
}